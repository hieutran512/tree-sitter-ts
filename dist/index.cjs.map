{"version":3,"sources":["../src/index.ts","../src/lexer/char-reader.ts","../src/lexer/state-machine.ts","../src/lexer/char-classes.ts","../src/lexer/matcher-compiler.ts","../src/lexer/lexer.ts","../src/parser/block-tracker.ts","../src/parser/symbol-detector.ts","../src/parser/structure-parser.ts","../src/profiles/json.ts","../src/profiles/css.ts","../src/profiles/scss.ts","../src/profiles/python.ts","../src/profiles/go.ts","../src/profiles/javascript.ts","../src/profiles/typescript.ts","../src/profiles/cpp.ts","../src/profiles/html.ts","../src/profiles/markdown.ts","../src/profiles/common.ts","../src/profiles/yaml.ts","../src/profiles/xml.ts","../src/profiles/java.ts","../src/profiles/csharp.ts","../src/profiles/rust.ts","../src/profiles/ruby.ts","../src/profiles/php.ts","../src/profiles/kotlin.ts","../src/profiles/swift.ts","../src/profiles/shell.ts","../src/profiles/bash.ts","../src/profiles/sql.ts","../src/profiles/toml.ts","../src/profiles/resolver.ts","../src/profiles/index.ts"],"sourcesContent":["// ---------------------------------------------------------------------------\n// tree-sitter-ts - Pure TypeScript parser library with declarative language profiles\n// ---------------------------------------------------------------------------\n\nimport type { LanguageProfile } from \"./schema/profile.js\";\nimport type { Token } from \"./types/token.js\";\nimport type { CodeSymbol } from \"./types/tree.js\";\nimport { tokenizeWithConfig } from \"./lexer/lexer.js\";\nimport { extractSymbolsFromProfile } from \"./parser/structure-parser.js\";\nimport { getProfile as getProfileFromRegistry } from \"./profiles/index.js\";\n\n// ======================== PUBLIC API ========================\n\n/**\n * Tokenize source code into a token stream.\n *\n * @param source - The source code to tokenize\n * @param language - Language name (e.g., 'typescript') or file extension (e.g., '.ts')\n * @returns Array of tokens with type, value, category, and position\n */\nexport function tokenize(source: string, language: string): Token[] {\n  const profile = resolveLanguage(language);\n  return tokenizeWithConfig(source, profile.lexer);\n}\n\n/**\n * Extract code symbols (functions, classes, etc.) from source code.\n * Requires the language profile to have structure rules (Level 2).\n *\n * @param source - The source code to analyze\n * @param language - Language name or file extension\n * @returns Array of symbols with name, kind, nameRange, and contentRange\n */\nexport function extractSymbols(\n  source: string,\n  language: string,\n): CodeSymbol[] {\n  const profile = resolveLanguage(language);\n  return extractSymbolsFromProfile(source, profile);\n}\n\n/**\n * Tokenize source code using a specific language profile.\n *\n * @param source - The source code to tokenize\n * @param profile - The language profile to use\n * @returns Array of tokens\n */\nexport function tokenizeWithProfile(\n  source: string,\n  profile: LanguageProfile,\n): Token[] {\n  return tokenizeWithConfig(source, profile.lexer);\n}\n\n/**\n * Extract code symbols using a specific language profile.\n *\n * @param source - The source code to analyze\n * @param profile - The language profile to use\n * @returns Array of symbols\n */\nexport function extractSymbolsWithProfile(\n  source: string,\n  profile: LanguageProfile,\n): CodeSymbol[] {\n  return extractSymbolsFromProfile(source, profile);\n}\n\n// ======================== HELPERS ========================\n\nfunction resolveLanguage(language: string): LanguageProfile {\n  const profile = getProfileFromRegistry(language);\n  if (!profile) {\n    throw new Error(\n      `Unknown language: \"${language}\". Use getRegisteredLanguages() to see available languages.`,\n    );\n  }\n  return profile;\n}\n\n// ======================== RE-EXPORTS ========================\n\n// Schema types\nexport type {\n  Position,\n  Range,\n  PredefinedCharClass,\n  CharClass,\n  TokenCategory,\n  SymbolKind,\n} from \"./schema/common.js\";\n\nexport type {\n  LexerConfig,\n  TokenTypeDef,\n  LexerState,\n  LexerRule,\n  Matcher,\n  StringMatcher,\n  KeywordsMatcher,\n  DelimitedMatcher,\n  LineMatcher,\n  CharSequenceMatcher,\n  NumberMatcher,\n  SequenceMatcher,\n  PatternMatcher,\n  IndentationConfig,\n} from \"./schema/lexer.js\";\n\nexport type {\n  StructureConfig,\n  BlockRule,\n  SymbolRule,\n  TokenPatternStep,\n  TokenMatchStep,\n  TokenSkipStep,\n  TokenOptionalStep,\n  TokenAnyOfStep,\n  FoldingRule,\n} from \"./schema/structure.js\";\n\nexport type {\n  GrammarConfig,\n  GrammarRule,\n  Production,\n  ProductionElement,\n  TokenElement,\n  RuleElement,\n  OptionalElement,\n  RepeatElement,\n  ChoiceElement,\n  PrecElement,\n  PrecedenceLevel,\n  RecoveryStrategy,\n} from \"./schema/grammar.js\";\n\nexport type {\n  LanguageProfile,\n  EmbeddedLanguageRule,\n} from \"./schema/profile.js\";\n\n// Output types\nexport type { Token } from \"./types/token.js\";\nexport type { SyntaxNode, CodeSymbol } from \"./types/tree.js\";\n\n// Lexer internals (for advanced usage)\nexport { CompiledLexer, getCompiledLexer } from \"./lexer/lexer.js\";\nexport { CharReader } from \"./lexer/char-reader.js\";\nexport { compileMatcher } from \"./lexer/matcher-compiler.js\";\nexport { compileCharClass } from \"./lexer/char-classes.js\";\n\n// Parser internals (for advanced usage)\nexport { findBlockSpans, type BlockSpan } from \"./parser/block-tracker.js\";\nexport { extractSymbolsFromTokens } from \"./parser/structure-parser.js\";\n\n// Profiles and registry\nexport {\n  json,\n  css,\n  scss,\n  python,\n  go,\n  javascript,\n  typescript,\n  cpp,\n  html,\n  markdown,\n  yaml,\n  xml,\n  java,\n  csharp,\n  rust,\n  ruby,\n  php,\n  kotlin,\n  swift,\n  shell,\n  bash,\n  sql,\n  toml,\n  builtinProfiles,\n  registerProfile,\n  getProfile,\n  getRegisteredLanguages,\n  getSupportedExtensions,\n  resolveProfile,\n} from \"./profiles/index.js\";\n","// ---------------------------------------------------------------------------\n// CharReader - character-by-character source reader with position tracking\n// ---------------------------------------------------------------------------\n\nimport type { Position } from \"../schema/common.js\";\n\n/** Reads source code character by character, tracking line/column/offset */\nexport class CharReader {\n  private readonly src: string;\n  private readonly len: number;\n  private pos = 0;\n  private line = 1;\n  private col = 0;\n\n  constructor(source: string) {\n    this.src = source;\n    this.len = source.length;\n  }\n\n  /** Current byte offset */\n  get offset(): number {\n    return this.pos;\n  }\n\n  /** Whether we've reached end of source */\n  get eof(): boolean {\n    return this.pos >= this.len;\n  }\n\n  /** Remaining characters from current position */\n  get remaining(): number {\n    return this.len - this.pos;\n  }\n\n  /** Current position as Position object */\n  get position(): Position {\n    return { line: this.line, column: this.col, offset: this.pos };\n  }\n\n  /** Peek at the current character without advancing */\n  peek(): string {\n    return this.pos < this.len ? this.src[this.pos] : \"\";\n  }\n\n  /** Peek at character at offset from current position */\n  peekAt(offset: number): string {\n    const idx = this.pos + offset;\n    return idx < this.len ? this.src[idx] : \"\";\n  }\n\n  /** Peek at a substring from current position */\n  peekString(length: number): string {\n    return this.src.slice(this.pos, this.pos + length);\n  }\n\n  /** Get the char code at current position */\n  peekCode(): number {\n    return this.pos < this.len ? this.src.charCodeAt(this.pos) : -1;\n  }\n\n  /** Advance one character and return it */\n  advance(): string {\n    if (this.pos >= this.len) return \"\";\n    const ch = this.src[this.pos];\n    this.pos++;\n    if (ch === \"\\n\") {\n      this.line++;\n      this.col = 0;\n    } else if (ch === \"\\r\") {\n      // Handle \\r\\n as single newline\n      if (this.pos < this.len && this.src[this.pos] === \"\\n\") {\n        this.pos++;\n      }\n      this.line++;\n      this.col = 0;\n    } else {\n      this.col++;\n    }\n    return ch;\n  }\n\n  /** Advance N characters and return the consumed substring */\n  advanceN(n: number): string {\n    const start = this.pos;\n    for (let i = 0; i < n && this.pos < this.len; i++) {\n      this.advance();\n    }\n    return this.src.slice(start, this.pos);\n  }\n\n  /** Check if source starts with the given string at current position */\n  startsWith(str: string): boolean {\n    if (this.pos + str.length > this.len) return false;\n    for (let i = 0; i < str.length; i++) {\n      if (this.src[this.pos + i] !== str[i]) return false;\n    }\n    return true;\n  }\n\n  /** Get a slice of the source from start offset to current position */\n  sliceFrom(startOffset: number): string {\n    return this.src.slice(startOffset, this.pos);\n  }\n\n  /** Get the full source string */\n  get source(): string {\n    return this.src;\n  }\n\n  /** Save current state for backtracking */\n  save(): ReaderState {\n    return { pos: this.pos, line: this.line, col: this.col };\n  }\n\n  /** Restore a previously saved state */\n  restore(state: ReaderState): void {\n    this.pos = state.pos;\n    this.line = state.line;\n    this.col = state.col;\n  }\n}\n\n/** Saved reader state for backtracking */\nexport interface ReaderState {\n  pos: number;\n  line: number;\n  col: number;\n}\n","// ---------------------------------------------------------------------------\n// Lexer State Machine\n//\n// Manages the lexer state stack for context-dependent tokenization.\n// Supports push (enter nested context), pop (leave context), and\n// switchTo (replace current context).\n// ---------------------------------------------------------------------------\n\n/** Manages the lexer state stack */\nexport class StateMachine {\n  private readonly stack: string[];\n\n  constructor(initialState: string) {\n    this.stack = [initialState];\n  }\n\n  /** Current state name */\n  get current(): string {\n    return this.stack[this.stack.length - 1];\n  }\n\n  /** Stack depth */\n  get depth(): number {\n    return this.stack.length;\n  }\n\n  /** Push a new state onto the stack */\n  push(state: string): void {\n    this.stack.push(state);\n  }\n\n  /** Pop the current state. Never pops the last state. */\n  pop(): void {\n    if (this.stack.length > 1) {\n      this.stack.pop();\n    }\n  }\n\n  /** Replace the current state */\n  switchTo(state: string): void {\n    this.stack[this.stack.length - 1] = state;\n  }\n\n  /** Apply transitions from a matched rule */\n  applyTransition(rule: {\n    push?: string;\n    pop?: boolean;\n    switchTo?: string;\n  }): void {\n    if (rule.push) {\n      this.push(rule.push);\n    } else if (rule.pop) {\n      this.pop();\n    } else if (rule.switchTo) {\n      this.switchTo(rule.switchTo);\n    }\n  }\n\n  /** Save current stack state for backtracking */\n  save(): string[] {\n    return [...this.stack];\n  }\n\n  /** Restore a previously saved stack state */\n  restore(saved: string[]): void {\n    this.stack.length = 0;\n    this.stack.push(...saved);\n  }\n}\n","// ---------------------------------------------------------------------------\n// Character class evaluation\n// ---------------------------------------------------------------------------\n\nimport type { CharClass } from \"../schema/common.js\";\n\n/**\n * Compile a CharClass definition into a fast character-test function.\n * Named references are resolved via the provided charClasses map.\n */\nexport function compileCharClass(\n  def: CharClass,\n  charClasses: Record<string, CharClass> = {},\n): (ch: string) => boolean {\n  return buildTest(def, charClasses);\n}\n\nfunction buildTest(\n  def: CharClass,\n  refs: Record<string, CharClass>,\n): (ch: string) => boolean {\n  if (\"predefined\" in def) {\n    switch (def.predefined) {\n      case \"letter\":\n        return (ch) => /^[a-zA-Z\\u00C0-\\u024F]$/.test(ch);\n      case \"upper\":\n        return (ch) => ch >= \"A\" && ch <= \"Z\";\n      case \"lower\":\n        return (ch) => ch >= \"a\" && ch <= \"z\";\n      case \"digit\":\n        return (ch) => ch >= \"0\" && ch <= \"9\";\n      case \"hexDigit\":\n        return (ch) =>\n          (ch >= \"0\" && ch <= \"9\") ||\n          (ch >= \"a\" && ch <= \"f\") ||\n          (ch >= \"A\" && ch <= \"F\");\n      case \"alphanumeric\":\n        return (ch) =>\n          /^[a-zA-Z\\u00C0-\\u024F]$/.test(ch) ||\n          (ch >= \"0\" && ch <= \"9\");\n      case \"whitespace\":\n        return (ch) => ch === \" \" || ch === \"\\t\";\n      case \"newline\":\n        return (ch) => ch === \"\\n\" || ch === \"\\r\";\n      case \"any\":\n        return (ch) => ch.length > 0;\n    }\n  }\n  if (\"chars\" in def) {\n    const set = new Set(def.chars);\n    return (ch) => set.has(ch);\n  }\n  if (\"range\" in def) {\n    const [lo, hi] = def.range;\n    return (ch) => ch >= lo && ch <= hi;\n  }\n  if (\"union\" in def) {\n    const tests = def.union.map((c) => buildTest(c, refs));\n    return (ch) => tests.some((t) => t(ch));\n  }\n  if (\"negate\" in def) {\n    const inner = buildTest(def.negate, refs);\n    return (ch) => ch.length > 0 && !inner(ch);\n  }\n  if (\"ref\" in def) {\n    const resolved = refs[def.ref];\n    if (!resolved) {\n      throw new Error(`Unknown charClass reference: \"${def.ref}\"`);\n    }\n    return buildTest(resolved, refs);\n  }\n  throw new Error(`Unknown CharClass variant: ${JSON.stringify(def)}`);\n}\n","// ---------------------------------------------------------------------------\n// Matcher Compiler\n//\n// Compiles declarative Matcher definitions into executable scanner functions.\n// Each compiled function takes a CharReader and returns the number of\n// characters consumed (0 = no match).\n// ---------------------------------------------------------------------------\n\nimport type { CharClass } from \"../schema/common.js\";\nimport type { Matcher } from \"../schema/lexer.js\";\nimport type { CharReader } from \"./char-reader.js\";\nimport { compileCharClass } from \"./char-classes.js\";\n\n/** A compiled scanner: returns chars consumed (0 = no match) */\nexport type ScanFn = (reader: CharReader) => number;\n\n/**\n * Compile a Matcher definition into an executable ScanFn.\n * The charClasses map provides named character class resolution.\n */\nexport function compileMatcher(\n  matcher: Matcher,\n  charClasses: Record<string, CharClass> = {},\n): ScanFn {\n  switch (matcher.kind) {\n    case \"string\":\n      return compileStringMatcher(matcher.value);\n    case \"keywords\":\n      return compileKeywordsMatcher(matcher.words);\n    case \"delimited\":\n      return compileDelimitedMatcher(\n        matcher.open,\n        matcher.close,\n        matcher.escape,\n        matcher.multiline ?? false,\n        matcher.nested ?? false,\n      );\n    case \"line\":\n      return compileLineMatcher(matcher.start);\n    case \"charSequence\":\n      return compileCharSequenceMatcher(\n        matcher.first,\n        matcher.rest,\n        charClasses,\n      );\n    case \"number\":\n      return compileNumberMatcher(matcher);\n    case \"sequence\":\n      return compileSequenceMatcher(matcher.elements, charClasses);\n    case \"pattern\":\n      return compilePatternMatcher(matcher.regex);\n  }\n}\n\n// ---------------------------------------------------------------------------\n// String matcher: exact string or array of strings (longest match)\n// ---------------------------------------------------------------------------\n\nfunction compileStringMatcher(value: string | string[]): ScanFn {\n  if (typeof value === \"string\") {\n    const len = value.length;\n    return (reader) => (reader.startsWith(value) ? len : 0);\n  }\n  // Sort by length descending for longest match first\n  const sorted = [...value].sort((a, b) => b.length - a.length);\n  return (reader) => {\n    for (const s of sorted) {\n      if (reader.startsWith(s)) return s.length;\n    }\n    return 0;\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Keywords matcher: word-boundary-aware exact match\n// ---------------------------------------------------------------------------\n\nfunction compileKeywordsMatcher(words: string[]): ScanFn {\n  // Sort by length descending for longest match first\n  const sorted = [...words].sort((a, b) => b.length - a.length);\n  return (reader) => {\n    for (const word of sorted) {\n      if (!reader.startsWith(word)) continue;\n      // Check word boundary after the keyword\n      const afterIdx = word.length;\n      const after = reader.peekAt(afterIdx);\n      if (after === \"\" || !isWordChar(after)) {\n        // Check word boundary before (char before current position)\n        // The lexer processes left-to-right, so if we're here, the previous\n        // token ended, meaning we're at a boundary. But we also need to check\n        // that we're not in the middle of an identifier. We check the char\n        // immediately before the reader's current position in the source.\n        const beforeIdx = reader.offset - 1;\n        if (beforeIdx < 0 || !isWordChar(reader.source[beforeIdx])) {\n          return word.length;\n        }\n      }\n    }\n    return 0;\n  };\n}\n\nfunction isWordChar(ch: string): boolean {\n  return /^[a-zA-Z0-9_$]$/.test(ch);\n}\n\n// ---------------------------------------------------------------------------\n// Delimited matcher: content between open/close markers\n// ---------------------------------------------------------------------------\n\nfunction compileDelimitedMatcher(\n  open: string,\n  close: string,\n  escape: string | undefined,\n  multiline: boolean,\n  nested: boolean,\n): ScanFn {\n  const openLen = open.length;\n  const closeLen = close.length;\n\n  return (reader) => {\n    if (!reader.startsWith(open)) return 0;\n\n    const startPos = reader.offset;\n    const src = reader.source;\n    let pos = startPos + openLen;\n    let depth = 1;\n\n    while (pos < src.length) {\n      // Check escape character\n      if (escape && src[pos] === escape) {\n        pos += 2; // skip escaped char\n        continue;\n      }\n\n      // Check for nested open (if nesting enabled)\n      if (nested && matchAt(src, pos, open)) {\n        depth++;\n        pos += openLen;\n        continue;\n      }\n\n      // Check for close\n      if (matchAt(src, pos, close)) {\n        depth--;\n        if (depth === 0) {\n          return pos + closeLen - startPos;\n        }\n        pos += closeLen;\n        continue;\n      }\n\n      // Check newline restriction\n      if (!multiline && (src[pos] === \"\\n\" || src[pos] === \"\\r\")) {\n        return 0; // unmatched - hit newline in single-line mode\n      }\n\n      pos++;\n    }\n\n    return 0; // unmatched - hit EOF\n  };\n}\n\nfunction matchAt(src: string, pos: number, str: string): boolean {\n  for (let i = 0; i < str.length; i++) {\n    if (src[pos + i] !== str[i]) return false;\n  }\n  return true;\n}\n\n// ---------------------------------------------------------------------------\n// Line matcher: from marker to end of line\n// ---------------------------------------------------------------------------\n\nfunction compileLineMatcher(start: string): ScanFn {\n  const startLen = start.length;\n  return (reader) => {\n    if (!reader.startsWith(start)) return 0;\n    const src = reader.source;\n    let pos = reader.offset + startLen;\n    while (pos < src.length && src[pos] !== \"\\n\" && src[pos] !== \"\\r\") {\n      pos++;\n    }\n    return pos - reader.offset;\n  };\n}\n\n// ---------------------------------------------------------------------------\n// CharSequence matcher: sequences of characters from a class\n// ---------------------------------------------------------------------------\n\nfunction compileCharSequenceMatcher(\n  first: CharClass,\n  rest: CharClass | undefined,\n  charClasses: Record<string, CharClass>,\n): ScanFn {\n  const testFirst = compileCharClass(first, charClasses);\n  const testRest = rest ? compileCharClass(rest, charClasses) : null;\n\n  return (reader) => {\n    const ch = reader.peek();\n    if (!ch || !testFirst(ch)) return 0;\n\n    if (!testRest) return 1; // single char match\n\n    const src = reader.source;\n    let pos = reader.offset + 1;\n    while (pos < src.length && testRest(src[pos])) {\n      pos++;\n    }\n    return pos - reader.offset;\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Number matcher: numeric literals\n// ---------------------------------------------------------------------------\n\nfunction compileNumberMatcher(opts: {\n  integer?: boolean;\n  float?: boolean;\n  hex?: boolean;\n  octal?: boolean;\n  binary?: boolean;\n  scientific?: boolean;\n  separator?: string;\n  suffix?: string[];\n}): ScanFn {\n  return (reader) => {\n    const src = reader.source;\n    const start = reader.offset;\n    let pos = start;\n\n    // Check for prefix-based formats (0x, 0o, 0b)\n    if (pos < src.length && src[pos] === \"0\" && pos + 1 < src.length) {\n      const next = src[pos + 1];\n\n      // Hex: 0x or 0X\n      if (opts.hex && (next === \"x\" || next === \"X\")) {\n        pos += 2;\n        const hexStart = pos;\n        while (pos < src.length && isHexDigit(src[pos])) {\n          pos++;\n          if (opts.separator && pos < src.length && src[pos] === opts.separator) {\n            pos++;\n          }\n        }\n        if (pos === hexStart) return 0; // no digits after 0x\n        return consumeSuffix(src, pos, opts.suffix) - start;\n      }\n\n      // Octal: 0o or 0O\n      if (opts.octal && (next === \"o\" || next === \"O\")) {\n        pos += 2;\n        const octStart = pos;\n        while (pos < src.length && src[pos] >= \"0\" && src[pos] <= \"7\") {\n          pos++;\n          if (opts.separator && pos < src.length && src[pos] === opts.separator) {\n            pos++;\n          }\n        }\n        if (pos === octStart) return 0;\n        return consumeSuffix(src, pos, opts.suffix) - start;\n      }\n\n      // Binary: 0b or 0B\n      if (opts.binary && (next === \"b\" || next === \"B\")) {\n        pos += 2;\n        const binStart = pos;\n        while (pos < src.length && (src[pos] === \"0\" || src[pos] === \"1\")) {\n          pos++;\n          if (opts.separator && pos < src.length && src[pos] === opts.separator) {\n            pos++;\n          }\n        }\n        if (pos === binStart) return 0;\n        return consumeSuffix(src, pos, opts.suffix) - start;\n      }\n    }\n\n    // Decimal integer/float\n    if (!opts.integer && !opts.float) return 0;\n\n    // Must start with digit or dot-digit for floats\n    const isDigit = pos < src.length && src[pos] >= \"0\" && src[pos] <= \"9\";\n    const isDotDigit =\n      opts.float &&\n      pos < src.length &&\n      src[pos] === \".\" &&\n      pos + 1 < src.length &&\n      src[pos + 1] >= \"0\" &&\n      src[pos + 1] <= \"9\";\n\n    if (!isDigit && !isDotDigit) return 0;\n\n    // Consume integer part\n    while (pos < src.length && src[pos] >= \"0\" && src[pos] <= \"9\") {\n      pos++;\n      if (opts.separator && pos < src.length && src[pos] === opts.separator) {\n        pos++;\n      }\n    }\n\n    // Consume decimal part\n    if (opts.float && pos < src.length && src[pos] === \".\") {\n      const afterDot = pos + 1;\n      if (afterDot < src.length && src[afterDot] >= \"0\" && src[afterDot] <= \"9\") {\n        pos = afterDot;\n        while (pos < src.length && src[pos] >= \"0\" && src[pos] <= \"9\") {\n          pos++;\n          if (opts.separator && pos < src.length && src[pos] === opts.separator) {\n            pos++;\n          }\n        }\n      }\n    }\n\n    // No digits consumed\n    if (pos === start) return 0;\n\n    // Scientific notation\n    if (\n      opts.scientific &&\n      pos < src.length &&\n      (src[pos] === \"e\" || src[pos] === \"E\")\n    ) {\n      let ePos = pos + 1;\n      if (ePos < src.length && (src[ePos] === \"+\" || src[ePos] === \"-\")) {\n        ePos++;\n      }\n      const eDigitStart = ePos;\n      while (ePos < src.length && src[ePos] >= \"0\" && src[ePos] <= \"9\") {\n        ePos++;\n      }\n      if (ePos > eDigitStart) {\n        pos = ePos;\n      }\n    }\n\n    return consumeSuffix(src, pos, opts.suffix) - start;\n  };\n}\n\nfunction isHexDigit(ch: string): boolean {\n  return (\n    (ch >= \"0\" && ch <= \"9\") ||\n    (ch >= \"a\" && ch <= \"f\") ||\n    (ch >= \"A\" && ch <= \"F\")\n  );\n}\n\nfunction consumeSuffix(\n  src: string,\n  pos: number,\n  suffixes: string[] | undefined,\n): number {\n  if (!suffixes) return pos;\n  // Try longest suffix first\n  for (const suf of [...suffixes].sort((a, b) => b.length - a.length)) {\n    if (matchAt(src, pos, suf)) {\n      return pos + suf.length;\n    }\n  }\n  return pos;\n}\n\n// ---------------------------------------------------------------------------\n// Sequence matcher: all elements must match in order\n// ---------------------------------------------------------------------------\n\nfunction compileSequenceMatcher(\n  elements: Matcher[],\n  charClasses: Record<string, CharClass>,\n): ScanFn {\n  const fns = elements.map((e) => compileMatcher(e, charClasses));\n  return (reader) => {\n    const saved = reader.save();\n    let total = 0;\n    for (const fn of fns) {\n      const n = fn(reader);\n      if (n === 0) {\n        reader.restore(saved);\n        return 0;\n      }\n      // Advance reader past what was matched\n      reader.advanceN(n);\n      total += n;\n    }\n    // Restore reader to original position - the lexer will do the actual advance\n    reader.restore(saved);\n    return total;\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Pattern matcher: regex escape hatch\n// ---------------------------------------------------------------------------\n\nfunction compilePatternMatcher(regex: string): ScanFn {\n  const re = new RegExp(\"^(?:\" + regex + \")\");\n  return (reader) => {\n    const src = reader.source;\n    const sub = src.slice(reader.offset);\n    const m = re.exec(sub);\n    return m ? m[0].length : 0;\n  };\n}\n","// ---------------------------------------------------------------------------\n// Lexer Engine\n//\n// The main tokenizer. Takes source code + a LexerConfig (from a language\n// profile) and produces a Token[] stream.\n// ---------------------------------------------------------------------------\n\nimport type { LexerConfig, LexerRule } from \"../schema/lexer.js\";\nimport type { Token } from \"../types/token.js\";\nimport { CharReader } from \"./char-reader.js\";\nimport { StateMachine } from \"./state-machine.js\";\nimport { compileMatcher, type ScanFn } from \"./matcher-compiler.js\";\n\n/** Pre-compiled rule: scanner function + rule metadata */\ninterface CompiledRule {\n  scan: ScanFn;\n  rule: LexerRule;\n}\n\n/** Pre-compiled state: array of compiled rules */\ntype CompiledState = CompiledRule[];\n\n/** Compiled lexer ready to tokenize */\nexport class CompiledLexer {\n  private readonly states: Map<string, CompiledState>;\n  private readonly config: LexerConfig;\n\n  constructor(config: LexerConfig) {\n    this.config = config;\n    this.states = new Map();\n\n    const charClasses = config.charClasses ?? {};\n\n    // Pre-compile all states and their rules\n    for (const [name, state] of Object.entries(config.states)) {\n      const compiled: CompiledState = state.rules.map((rule) => ({\n        scan: compileMatcher(rule.match, charClasses),\n        rule,\n      }));\n      this.states.set(name, compiled);\n    }\n  }\n\n  /** Tokenize source code into a token stream */\n  tokenize(source: string): Token[] {\n    const reader = new CharReader(source);\n    const sm = new StateMachine(this.config.initialState);\n    const tokens: Token[] = [];\n\n    while (!reader.eof) {\n      const currentState = this.states.get(sm.current);\n      if (!currentState) {\n        throw new Error(`Unknown lexer state: \"${sm.current}\"`);\n      }\n\n      let matched = false;\n      const startPos = reader.position;\n\n      for (const { scan, rule } of currentState) {\n        const consumed = scan(reader);\n        if (consumed > 0) {\n          const value = reader.advanceN(consumed);\n          const endPos = reader.position;\n\n          const typeDef = this.config.tokenTypes[rule.token];\n          tokens.push({\n            type: rule.token,\n            value,\n            category: typeDef?.category ?? \"plain\",\n            range: { start: startPos, end: endPos },\n          });\n\n          // Apply state transition\n          sm.applyTransition(rule);\n          matched = true;\n          break;\n        }\n      }\n\n      if (!matched) {\n        // Fallback: consume single character as error/plain token\n        const ch = reader.advance();\n        const endPos = reader.position;\n        tokens.push({\n          type: \"error\",\n          value: ch,\n          category: \"error\",\n          range: { start: startPos, end: endPos },\n        });\n      }\n    }\n\n    return tokens;\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Convenience: one-shot tokenize\n// ---------------------------------------------------------------------------\n\n/** Cache of compiled lexers keyed by config reference */\nconst lexerCache = new WeakMap<LexerConfig, CompiledLexer>();\n\n/** Get or create a compiled lexer for the given config */\nexport function getCompiledLexer(config: LexerConfig): CompiledLexer {\n  let lexer = lexerCache.get(config);\n  if (!lexer) {\n    lexer = new CompiledLexer(config);\n    lexerCache.set(config, lexer);\n  }\n  return lexer;\n}\n\n/** Tokenize source code using a lexer config */\nexport function tokenizeWithConfig(\n  source: string,\n  config: LexerConfig,\n): Token[] {\n  return getCompiledLexer(config).tokenize(source);\n}\n","// ---------------------------------------------------------------------------\n// Block Tracker\n//\n// Tracks brace/bracket/paren nesting from BlockRule definitions.\n// Used by the Symbol Detector to find where symbol bodies end.\n// ---------------------------------------------------------------------------\n\nimport type { BlockRule } from \"../schema/structure.js\";\nimport type { Token } from \"../types/token.js\";\n\n/** A matched block with open/close token indices */\nexport interface BlockSpan {\n  /** Block rule name */\n  name: string;\n  /** Index of opening token in the token array */\n  openIndex: number;\n  /** Index of closing token in the token array */\n  closeIndex: number;\n  /** Nesting depth (0 = top level) */\n  depth: number;\n}\n\n/**\n * Find all block spans in a token array using the given block rules.\n * Returns spans sorted by openIndex.\n */\nexport function findBlockSpans(\n  tokens: Token[],\n  blockRules: BlockRule[],\n): BlockSpan[] {\n  // Build lookup maps\n  const openToRule = new Map<string, BlockRule>();\n  const closeToRule = new Map<string, BlockRule>();\n  for (const rule of blockRules) {\n    openToRule.set(rule.open, rule);\n    closeToRule.set(rule.close, rule);\n  }\n\n  const spans: BlockSpan[] = [];\n  // Stack of [ruleName, openIndex, depth]\n  const stack: Array<{ name: string; openIndex: number; depth: number }> = [];\n\n  for (let i = 0; i < tokens.length; i++) {\n    const val = tokens[i].value;\n\n    const openRule = openToRule.get(val);\n    if (openRule) {\n      stack.push({ name: openRule.name, openIndex: i, depth: stack.length });\n      continue;\n    }\n\n    const closeRule = closeToRule.get(val);\n    if (closeRule) {\n      // Find matching open on the stack (search from top)\n      for (let j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].name === closeRule.name) {\n          const entry = stack[j];\n          spans.push({\n            name: entry.name,\n            openIndex: entry.openIndex,\n            closeIndex: i,\n            depth: entry.depth,\n          });\n          // Remove this entry and everything above it (mismatched closes)\n          stack.length = j;\n          break;\n        }\n      }\n    }\n  }\n\n  spans.sort((a, b) => a.openIndex - b.openIndex);\n  return spans;\n}\n\n/**\n * Given an opening token index, find the matching closing token index.\n * Uses the precomputed block spans.\n */\nexport function findMatchingClose(\n  spans: BlockSpan[],\n  openIndex: number,\n): number | undefined {\n  for (const span of spans) {\n    if (span.openIndex === openIndex) return span.closeIndex;\n  }\n  return undefined;\n}\n\n/**\n * Find the block span that starts at or after the given token index\n * with the specified block rule name.\n */\nexport function findNextBlock(\n  spans: BlockSpan[],\n  afterIndex: number,\n  blockName: string,\n): BlockSpan | undefined {\n  for (const span of spans) {\n    if (span.openIndex >= afterIndex && span.name === blockName) {\n      return span;\n    }\n  }\n  return undefined;\n}\n","// ---------------------------------------------------------------------------\n// Symbol Detector\n//\n// Matches SymbolRule patterns against a token stream to identify\n// structural constructs (functions, classes, headings, tables, etc.).\n// ---------------------------------------------------------------------------\n\nimport type { SymbolRule, TokenPatternStep } from \"../schema/structure.js\";\nimport type { Token } from \"../types/token.js\";\nimport type { CodeSymbol } from \"../types/tree.js\";\nimport type { BlockSpan } from \"./block-tracker.js\";\nimport { findNextBlock } from \"./block-tracker.js\";\n\n/** Internal match result from pattern matching */\ninterface PatternMatch {\n  /** Token index where the match started */\n  startIndex: number;\n  /** Token index after the last matched token */\n  endIndex: number;\n  /** Captured values by name */\n  captures: Record<string, string>;\n  /** Captured token positions by capture name (index in filtered token array) */\n  captureIndices: Record<string, number>;\n}\n\n/**\n * Detect symbols in a token stream using the given symbol rules.\n * Skip tokens are filtered out before matching.\n */\nexport function detectSymbols(\n  tokens: Token[],\n  rules: SymbolRule[],\n  blockSpans: BlockSpan[],\n  skipTokens: Set<string>,\n): CodeSymbol[] {\n  // Build a filtered token array (skip whitespace/comments) but keep index mapping\n  const filtered: Array<{ token: Token; originalIndex: number }> = [];\n  for (let i = 0; i < tokens.length; i++) {\n    if (!skipTokens.has(tokens[i].type)) {\n      filtered.push({ token: tokens[i], originalIndex: i });\n    }\n  }\n\n  const symbols: CodeSymbol[] = [];\n  const used = new Set<number>(); // filtered indices already claimed\n\n  for (const rule of rules) {\n    for (let fi = 0; fi < filtered.length; fi++) {\n      if (used.has(fi)) continue;\n\n      const match = tryMatch(filtered, fi, rule.pattern);\n      if (!match) continue;\n\n      const name = match.captures[\"name\"] ?? rule.name;\n      const startOriginalIndex = filtered[match.startIndex].originalIndex;\n      const lastMatchOriginalIndex = filtered[match.endIndex - 1]?.originalIndex ?? startOriginalIndex;\n\n      let endOriginalIndex = lastMatchOriginalIndex;\n\n      // Find the body end\n      if (rule.hasBody) {\n        if (rule.bodyStyle === \"braces\") {\n          // Find the next brace block after the pattern match\n          const block = findNextBlock(blockSpans, lastMatchOriginalIndex, \"braces\");\n          if (block) {\n            endOriginalIndex = block.closeIndex;\n          }\n        } else if (rule.bodyStyle === \"indentation\") {\n          // For indentation-based bodies, find where indentation returns to\n          // the same or lower level\n          const baseIndent = tokens[startOriginalIndex].range.start.column;\n          endOriginalIndex = findIndentationEndIndex(tokens, lastMatchOriginalIndex, baseIndent);\n        } else if (rule.bodyStyle === \"markup-block\") {\n          // For markup blocks (Markdown tables, lists, blockquotes), find next blank line or EOF\n          endOriginalIndex = findMarkupBlockEndIndex(tokens, lastMatchOriginalIndex);\n        }\n      } else {\n        // No body: symbol ends at end of current line or semicolon\n        endOriginalIndex = findStatementEndIndex(tokens, lastMatchOriginalIndex);\n      }\n\n      const nameOriginalIndex =\n        match.captureIndices[\"name\"] !== undefined\n          ? filtered[match.captureIndices[\"name\"]].originalIndex\n          : startOriginalIndex;\n\n      const nameToken = tokens[nameOriginalIndex] ?? tokens[startOriginalIndex];\n      const startToken = tokens[startOriginalIndex];\n      const endToken = tokens[endOriginalIndex] ?? tokens[lastMatchOriginalIndex];\n\n      symbols.push({\n        name,\n        kind: rule.kind,\n        nameRange: nameToken.range,\n        contentRange: {\n          start: startToken.range.start,\n          end: endToken.range.end,\n        },\n      });\n\n      // Mark the matched filtered indices as used\n      for (let k = match.startIndex; k < match.endIndex; k++) {\n        used.add(k);\n      }\n    }\n  }\n\n  // Sort by content start position\n  symbols.sort((a, b) => {\n    if (a.contentRange.start.line === b.contentRange.start.line) {\n      return a.contentRange.start.column - b.contentRange.start.column;\n    }\n    return a.contentRange.start.line - b.contentRange.start.line;\n  });\n  return symbols;\n}\n\n// ---------------------------------------------------------------------------\n// Pattern matching against filtered tokens\n// ---------------------------------------------------------------------------\n\nfunction tryMatch(\n  filtered: Array<{ token: Token; originalIndex: number }>,\n  startIdx: number,\n  pattern: TokenPatternStep[],\n): PatternMatch | null {\n  const captures: Record<string, string> = {};\n  const captureIndices: Record<string, number> = {};\n  let idx = startIdx;\n\n  for (let pi = 0; pi < pattern.length; pi++) {\n    const step = pattern[pi];\n\n    if (idx >= filtered.length) return null;\n\n    if (\"skip\" in step && step.skip) {\n      // Skip: find next step match within maxTokens\n      const nextStep = pattern[pi + 1];\n      if (!nextStep) return null; // skip at end makes no sense\n      const maxTokens = step.maxTokens ?? 50;\n      let found = false;\n      const limit = Math.min(idx + maxTokens, filtered.length);\n      for (let si = idx; si < limit; si++) {\n        if (matchSingleStep(filtered[si].token, nextStep, captures, captureIndices, si)) {\n          idx = si;\n          found = true;\n          break;\n        }\n      }\n      if (!found) return null;\n      // The next iteration of the outer loop will re-process the nextStep\n      // So we skip the pi++ that would skip it\n      // Actually, we already matched nextStep at idx, so advance past it\n      idx++;\n      pi++; // skip the next pattern step since we matched it here\n      continue;\n    }\n\n    if (\"optional\" in step) {\n      // Try to match, but don't fail if it doesn't\n      if (matchSingleStep(filtered[idx].token, step.optional, captures, captureIndices, idx)) {\n        idx++;\n      }\n      continue;\n    }\n\n    if (\"anyOf\" in step) {\n      let anyMatched = false;\n      for (const alt of step.anyOf) {\n        if (matchSingleStep(filtered[idx].token, alt, captures, captureIndices, idx)) {\n          anyMatched = true;\n          idx++;\n          break;\n        }\n      }\n      if (!anyMatched) return null;\n      continue;\n    }\n\n    // Regular token match\n    if (\"token\" in step) {\n      if (!matchTokenStep(filtered[idx].token, step)) return null;\n      if (step.capture) {\n        captures[step.capture] = filtered[idx].token.value;\n        captureIndices[step.capture] = idx;\n      }\n      idx++;\n      continue;\n    }\n\n    return null; // unknown step type\n  }\n\n  return { startIndex: startIdx, endIndex: idx, captures, captureIndices };\n}\n\nfunction matchSingleStep(\n  token: Token,\n  step: TokenPatternStep,\n  captures: Record<string, string>,\n  captureIndices: Record<string, number>,\n  index: number,\n): boolean {\n  if (\"token\" in step) {\n    if (!matchTokenStep(token, step)) return false;\n    if (step.capture) {\n      captures[step.capture] = token.value;\n      captureIndices[step.capture] = index;\n    }\n    return true;\n  }\n  if (\"anyOf\" in step) {\n    return step.anyOf.some((alt) => matchSingleStep(token, alt, captures, captureIndices, index));\n  }\n  return false;\n}\n\nfunction matchTokenStep(\n  token: Token,\n  step: { token: string; value?: string },\n): boolean {\n  if (token.type !== step.token) return false;\n  if (step.value !== undefined && token.value !== step.value) return false;\n  return true;\n}\n\n// ---------------------------------------------------------------------------\n// End-line detection helpers\n// ---------------------------------------------------------------------------\n\n/** Find where an indentation-based body ends */\nfunction findIndentationEndIndex(\n  tokens: Token[],\n  afterIndex: number,\n  baseIndent: number,\n): number {\n  let lastContentIndex = afterIndex;\n  let foundBody = false;\n\n  for (let i = afterIndex + 1; i < tokens.length; i++) {\n    const tok = tokens[i];\n    // Skip whitespace and newlines\n    if (tok.category === \"whitespace\" || tok.category === \"newline\") continue;\n\n    const col = tok.range.start.column;\n\n    if (!foundBody) {\n      // First non-whitespace after the header - must be indented\n      if (col > baseIndent) {\n        foundBody = true;\n        lastContentIndex = i;\n      } else {\n        // Not indented - no body\n        return lastContentIndex;\n      }\n    } else {\n      // In body - check if we've de-dented back to base or further\n      if (col <= baseIndent) {\n        return lastContentIndex;\n      }\n      lastContentIndex = i;\n    }\n  }\n\n  return lastContentIndex;\n}\n\n/** Find the end of a statement (next newline or semicolon at depth 0) */\nfunction findStatementEndIndex(tokens: Token[], fromIndex: number): number {\n  let endIndex = fromIndex;\n  let depth = 0;\n\n  for (let i = fromIndex + 1; i < tokens.length; i++) {\n    const tok = tokens[i];\n\n    if (tok.value === \"{\" || tok.value === \"(\" || tok.value === \"[\") depth++;\n    if (tok.value === \"}\" || tok.value === \")\" || tok.value === \"]\") depth--;\n\n    if (depth === 0) {\n      if (tok.value === \";\") return i;\n      if (tok.category === \"newline\" && depth <= 0) return endIndex;\n    }\n\n    if (tok.category !== \"whitespace\" && tok.category !== \"newline\") {\n      endIndex = i;\n    }\n  }\n\n  return endIndex;\n}\n\n/** Find the end of a markup block (Markdown table/list/blockquote) by scanning until blank line */\nfunction findMarkupBlockEndIndex(tokens: Token[], fromIndex: number): number {\n  let endIndex = fromIndex;\n  let lastContentLine = tokens[fromIndex]?.range.start.line ?? 1;\n  let blankLineCount = 0;\n\n  for (let i = fromIndex + 1; i < tokens.length; i++) {\n    const tok = tokens[i];\n\n    if (tok.category === \"newline\") {\n      // Track consecutive blank lines (newlines with only whitespace between them)\n      if (i + 1 < tokens.length && tokens[i + 1].category === \"newline\") {\n        blankLineCount++;\n      } else {\n        blankLineCount = 0;\n      }\n\n      // Stop on blank line (two consecutive newlines or end of content)\n      if (blankLineCount > 0) {\n        return endIndex;\n      }\n      continue;\n    }\n\n    if (tok.category !== \"whitespace\") {\n      endIndex = i;\n      lastContentLine = tok.range.start.line;\n      blankLineCount = 0;\n    }\n  }\n\n  return endIndex;\n}\n","// ---------------------------------------------------------------------------\n// Structure Parser\n//\n// High-level API that combines the lexer, block tracker, and symbol\n// detector to extract CodeSymbol[] from source code.\n// ---------------------------------------------------------------------------\n\nimport type { LanguageProfile } from \"../schema/profile.js\";\nimport type { Token } from \"../types/token.js\";\nimport type { CodeSymbol } from \"../types/tree.js\";\nimport { tokenizeWithConfig } from \"../lexer/lexer.js\";\nimport { findBlockSpans } from \"./block-tracker.js\";\nimport { detectSymbols } from \"./symbol-detector.js\";\n\n/**\n * Extract code symbols from source code using a language profile.\n * Requires the profile to have a structure config (Level 2).\n * Returns an empty array if no structure config is present.\n */\nexport function extractSymbolsFromProfile(\n  source: string,\n  profile: LanguageProfile,\n): CodeSymbol[] {\n  if (!profile.structure) return [];\n\n  const tokens = tokenizeWithConfig(source, profile.lexer);\n  return extractSymbolsFromTokens(tokens, profile);\n}\n\n/**\n * Extract code symbols from a pre-tokenized token stream.\n * Useful when you already have tokens and want to avoid re-tokenizing.\n */\nexport function extractSymbolsFromTokens(\n  tokens: Token[],\n  profile: LanguageProfile,\n): CodeSymbol[] {\n  if (!profile.structure) return [];\n\n  const { blocks, symbols: symbolRules } = profile.structure;\n  const skipTokens = new Set(profile.lexer.skipTokens ?? []);\n\n  // Find all block spans (brace matching)\n  const blockSpans = findBlockSpans(tokens, blocks);\n\n  // Detect symbols using pattern matching\n  return detectSymbols(tokens, symbolRules, blockSpans, skipTokens);\n}\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** JSON language profile - Level 1 (Lexer) + Level 2 (Structure) + Level 3 (Grammar) */\nexport const json: LanguageProfile = {\n  name: \"json\",\n  displayName: \"JSON\",\n  version: \"1.0.0\",\n  fileExtensions: [\".json\"],\n  mimeTypes: [\"application/json\"],\n\n  lexer: {\n    tokenTypes: {\n      string: { category: \"string\" },\n      number: { category: \"number\" },\n      constant: { category: \"constant\" },\n      punctuation: { category: \"punctuation\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [\"whitespace\", \"newline\"],\n    states: {\n      default: {\n        rules: [\n          // Strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Numbers\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              scientific: true,\n            },\n            token: \"number\",\n          },\n          // Constants: true, false, null\n          {\n            match: { kind: \"keywords\", words: [\"true\", \"false\", \"null\"] },\n            token: \"constant\",\n          },\n          // Punctuation\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"}\", \"[\", \"]\", \":\", \",\"],\n            },\n            token: \"punctuation\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [\n      { name: \"object\", open: \"{\", close: \"}\" },\n      { name: \"array\", open: \"[\", close: \"]\" },\n    ],\n    symbols: [\n      {\n        name: \"object\",\n        kind: \"object\",\n        pattern: [{ token: \"punctuation\", value: \"{\" }],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"array\",\n        kind: \"array\",\n        pattern: [{ token: \"punctuation\", value: \"[\" }],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"pair\",\n        kind: \"pair\",\n        pattern: [\n          { token: \"string\", capture: \"name\" },\n          { token: \"punctuation\", value: \":\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"string_value\",\n        kind: \"string\",\n        pattern: [{ token: \"string\", capture: \"name\" }],\n        hasBody: false,\n      },\n      {\n        name: \"number_value\",\n        kind: \"number\",\n        pattern: [{ token: \"number\", capture: \"name\" }],\n        hasBody: false,\n      },\n      {\n        name: \"constant_value\",\n        kind: \"constant\",\n        pattern: [{ token: \"constant\", capture: \"name\" }],\n        hasBody: false,\n      },\n    ],\n  },\n\n  grammar: {\n    entry: \"value\",\n    rules: {\n      value: {\n        alternatives: [\n          [{ rule: \"object\" }],\n          [{ rule: \"array\" }],\n          [{ token: \"string\" }],\n          [{ token: \"number\" }],\n          [{ token: \"constant\" }],\n        ],\n      },\n      object: {\n        alternatives: [\n          [\n            { token: \"punctuation\", value: \"{\" },\n            {\n              optional: {\n                repeat: [{ rule: \"pair\" }],\n                min: 1,\n                separator: { token: \"punctuation\", value: \",\" },\n              },\n            },\n            { token: \"punctuation\", value: \"}\" },\n          ],\n        ],\n      },\n      pair: {\n        alternatives: [\n          [\n            { token: \"string\", field: \"key\" },\n            { token: \"punctuation\", value: \":\" },\n            { rule: \"value\", field: \"value\" },\n          ],\n        ],\n      },\n      array: {\n        alternatives: [\n          [\n            { token: \"punctuation\", value: \"[\" },\n            {\n              optional: {\n                repeat: [{ rule: \"value\" }],\n                min: 1,\n                separator: { token: \"punctuation\", value: \",\" },\n              },\n            },\n            { token: \"punctuation\", value: \"]\" },\n          ],\n        ],\n      },\n    },\n    recovery: [\n      { context: \"object\", syncTokens: [\"}\", \",\"] },\n      { context: \"array\", syncTokens: [\"]\", \",\"] },\n    ],\n  },\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** CSS language profile - Level 1 (Lexer) + Level 2 (Structure) */\nexport const css: LanguageProfile = {\n  name: \"css\",\n  displayName: \"CSS\",\n  version: \"1.0.0\",\n  fileExtensions: [\".css\"],\n  mimeTypes: [\"text/css\"],\n\n  lexer: {\n    charClasses: {\n      identStart: {\n        union: [{ predefined: \"letter\" }, { chars: \"_-\" }],\n      },\n      identPart: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"_-\" }],\n      },\n    },\n    tokenTypes: {\n      comment: { category: \"comment\" },\n      string: { category: \"string\" },\n      number: { category: \"number\" },\n      color: { category: \"constant\", subcategory: \"color\" },\n      keyword: { category: \"keyword\" },\n      at_rule: { category: \"keyword\", subcategory: \"at-rule\" },\n      property: { category: \"identifier\", subcategory: \"property\" },\n      selector: { category: \"tag\", subcategory: \"selector\" },\n      pseudo: { category: \"keyword\", subcategory: \"pseudo\" },\n      identifier: { category: \"identifier\" },\n      operator: { category: \"operator\" },\n      punctuation: { category: \"punctuation\" },\n      unit: { category: \"keyword\", subcategory: \"unit\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [\"whitespace\", \"newline\", \"comment\"],\n    states: {\n      default: {\n        rules: [\n          // Block comments\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"/*\",\n              close: \"*/\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          // Strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // At-rules (@media, @keyframes, @import, etc.)\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"@\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"letter\" },\n                  rest: { ref: \"identPart\" },\n                },\n              ],\n            },\n            token: \"at_rule\",\n          },\n          // Hex colors\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"#\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"hexDigit\" },\n                  rest: { predefined: \"hexDigit\" },\n                },\n              ],\n            },\n            token: \"color\",\n          },\n          // Numbers with units\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              suffix: [\n                \"px\",\n                \"em\",\n                \"rem\",\n                \"%\",\n                \"vh\",\n                \"vw\",\n                \"vmin\",\n                \"vmax\",\n                \"ch\",\n                \"ex\",\n                \"cm\",\n                \"mm\",\n                \"in\",\n                \"pt\",\n                \"pc\",\n                \"s\",\n                \"ms\",\n                \"deg\",\n                \"rad\",\n                \"grad\",\n                \"turn\",\n                \"fr\",\n                \"dpi\",\n                \"dpcm\",\n                \"dppx\",\n              ],\n            },\n            token: \"number\",\n          },\n          // Keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"important\",\n                \"inherit\",\n                \"initial\",\n                \"unset\",\n                \"revert\",\n                \"none\",\n                \"auto\",\n                \"normal\",\n                \"bold\",\n                \"italic\",\n                \"solid\",\n                \"dashed\",\n                \"dotted\",\n                \"block\",\n                \"inline\",\n                \"flex\",\n                \"grid\",\n                \"absolute\",\n                \"relative\",\n                \"fixed\",\n                \"sticky\",\n                \"static\",\n                \"hidden\",\n                \"visible\",\n                \"scroll\",\n                \"transparent\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          // Pseudo-classes and pseudo-elements\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"::\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"letter\" },\n                  rest: { ref: \"identPart\" },\n                },\n              ],\n            },\n            token: \"pseudo\",\n          },\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \":\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"letter\" },\n                  rest: { ref: \"identPart\" },\n                },\n              ],\n            },\n            token: \"pseudo\",\n          },\n          // Identifiers\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          // Operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\"+\", \">\", \"~\", \"*\", \"=\", \"^=\", \"$=\", \"*=\", \"|=\", \"~=\"],\n            },\n            token: \"operator\",\n          },\n          // Punctuation\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \";\", \":\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          // !important\n          {\n            match: { kind: \"string\", value: \"!\" },\n            token: \"operator\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [\n      { name: \"block\", open: \"{\", close: \"}\" },\n      { name: \"parens\", open: \"(\", close: \")\" },\n      { name: \"brackets\", open: \"[\", close: \"]\" },\n    ],\n    symbols: [\n      {\n        name: \"at_rule\",\n        kind: \"directive\",\n        pattern: [{ token: \"at_rule\", capture: \"name\" }],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n    ],\n    folding: [\n      { open: { token: \"punctuation\", value: \"{\" }, close: { token: \"punctuation\", value: \"}\" } },\n    ],\n  },\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** SCSS language profile - extends CSS with nesting, variables, mixins */\nexport const scss: LanguageProfile = {\n  name: \"scss\",\n  displayName: \"SCSS\",\n  version: \"1.0.0\",\n  fileExtensions: [\".scss\"],\n  mimeTypes: [\"text/x-scss\"],\n  extends: \"css\",\n\n  lexer: {\n    charClasses: {\n      identStart: {\n        union: [{ predefined: \"letter\" }, { chars: \"_-\" }],\n      },\n      identPart: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"_-\" }],\n      },\n    },\n    tokenTypes: {\n      comment: { category: \"comment\" },\n      string: { category: \"string\" },\n      number: { category: \"number\" },\n      color: { category: \"constant\", subcategory: \"color\" },\n      keyword: { category: \"keyword\" },\n      at_rule: { category: \"keyword\", subcategory: \"at-rule\" },\n      variable: { category: \"variable\" },\n      interpolation: { category: \"punctuation\", subcategory: \"interpolation\" },\n      pseudo: { category: \"keyword\", subcategory: \"pseudo\" },\n      identifier: { category: \"identifier\" },\n      operator: { category: \"operator\" },\n      punctuation: { category: \"punctuation\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [\"whitespace\", \"newline\", \"comment\"],\n    states: {\n      default: {\n        rules: [\n          // Line comments (SCSS-specific)\n          { match: { kind: \"line\", start: \"//\" }, token: \"comment\" },\n          // Block comments\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"/*\",\n              close: \"*/\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          // Strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Interpolation #{...}\n          {\n            match: { kind: \"string\", value: \"#{\" },\n            token: \"interpolation\",\n            push: \"interpolation\",\n          },\n          // SCSS variables ($variable)\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"$\" },\n                {\n                  kind: \"charSequence\",\n                  first: {\n                    union: [{ predefined: \"letter\" }, { chars: \"_\" }],\n                  },\n                  rest: { ref: \"identPart\" },\n                },\n              ],\n            },\n            token: \"variable\",\n          },\n          // At-rules (@mixin, @include, @extend, @import, @use, @forward, etc.)\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"@\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"letter\" },\n                  rest: { ref: \"identPart\" },\n                },\n              ],\n            },\n            token: \"at_rule\",\n          },\n          // Hex colors\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"#\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"hexDigit\" },\n                  rest: { predefined: \"hexDigit\" },\n                },\n              ],\n            },\n            token: \"color\",\n          },\n          // Numbers with units\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              suffix: [\n                \"px\", \"em\", \"rem\", \"%\", \"vh\", \"vw\", \"vmin\", \"vmax\",\n                \"ch\", \"ex\", \"s\", \"ms\", \"deg\", \"rad\", \"fr\",\n              ],\n            },\n            token: \"number\",\n          },\n          // Keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"important\", \"inherit\", \"initial\", \"unset\", \"none\", \"auto\",\n                \"true\", \"false\", \"null\", \"and\", \"or\", \"not\", \"from\", \"through\", \"to\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          // Pseudo selectors\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"::\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"letter\" },\n                  rest: { ref: \"identPart\" },\n                },\n              ],\n            },\n            token: \"pseudo\",\n          },\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \":\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"letter\" },\n                  rest: { ref: \"identPart\" },\n                },\n              ],\n            },\n            token: \"pseudo\",\n          },\n          // & (parent selector)\n          { match: { kind: \"string\", value: \"&\" }, token: \"operator\" },\n          // Identifiers\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          // Operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\"+\", \">\", \"~\", \"*\", \"=\", \"^=\", \"$=\", \"*=\", \"|=\", \"~=\"],\n            },\n            token: \"operator\",\n          },\n          // Punctuation\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \";\", \":\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          { match: { kind: \"string\", value: \"!\" }, token: \"operator\" },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n      interpolation: {\n        rules: [\n          {\n            match: { kind: \"string\", value: \"}\" },\n            token: \"interpolation\",\n            pop: true,\n          },\n          // Inside interpolation, use same rules as default\n          // (the engine will fall through to default state rules)\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [\n      { name: \"block\", open: \"{\", close: \"}\" },\n      { name: \"parens\", open: \"(\", close: \")\" },\n    ],\n    symbols: [\n      {\n        name: \"mixin_declaration\",\n        kind: \"function\",\n        pattern: [\n          { token: \"at_rule\", value: \"@mixin\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"function_declaration\",\n        kind: \"function\",\n        pattern: [\n          { token: \"at_rule\", value: \"@function\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"at_rule\",\n        kind: \"directive\",\n        pattern: [{ token: \"at_rule\", capture: \"name\" }],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n    ],\n    folding: [\n      { open: { token: \"punctuation\", value: \"{\" }, close: { token: \"punctuation\", value: \"}\" } },\n    ],\n  },\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** Python language profile - Level 1 (Lexer) + Level 2 (Structure) */\nexport const python: LanguageProfile = {\n  name: \"python\",\n  displayName: \"Python\",\n  version: \"1.0.0\",\n  fileExtensions: [\".py\", \".pyi\", \".pyw\"],\n  mimeTypes: [\"text/x-python\"],\n\n  lexer: {\n    charClasses: {\n      identStart: {\n        union: [{ predefined: \"letter\" }, { chars: \"_\" }],\n      },\n      identPart: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"_\" }],\n      },\n    },\n    tokenTypes: {\n      keyword: { category: \"keyword\" },\n      constant: { category: \"constant\" },\n      builtin: { category: \"keyword\", subcategory: \"builtin\" },\n      identifier: { category: \"identifier\" },\n      type_name: { category: \"type\" },\n      decorator: { category: \"decorator\" },\n      string: { category: \"string\" },\n      fstring_start: { category: \"string\", subcategory: \"fstring\" },\n      fstring_expr: { category: \"punctuation\", subcategory: \"fstring\" },\n      number: { category: \"number\" },\n      comment: { category: \"comment\" },\n      operator: { category: \"operator\" },\n      punctuation: { category: \"punctuation\" },\n      indent: { category: \"whitespace\" },\n      dedent: { category: \"whitespace\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [\"whitespace\", \"newline\", \"comment\", \"indent\", \"dedent\"],\n    indentation: {\n      indentToken: \"indent\",\n      dedentToken: \"dedent\",\n      unit: \"detect\",\n    },\n    states: {\n      default: {\n        rules: [\n          // Comments\n          { match: { kind: \"line\", start: \"#\" }, token: \"comment\" },\n          // Triple-quoted strings (must come before single-quoted)\n          {\n            match: {\n              kind: \"delimited\",\n              open: '\"\"\"',\n              close: '\"\"\"',\n              multiline: true,\n              escape: \"\\\\\",\n            },\n            token: \"string\",\n          },\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"'''\",\n              close: \"'''\",\n              multiline: true,\n              escape: \"\\\\\",\n            },\n            token: \"string\",\n          },\n          // F-string triple-quoted (consume whole thing for now)\n          {\n            match: {\n              kind: \"pattern\",\n              regex: '[fF]\"\"\"[\\\\s\\\\S]*?\"\"\"',\n            },\n            token: \"string\",\n          },\n          {\n            match: {\n              kind: \"pattern\",\n              regex: \"[fF]'''[\\\\s\\\\S]*?'''\",\n            },\n            token: \"string\",\n          },\n          // F-string single-quoted\n          {\n            match: {\n              kind: \"pattern\",\n              regex: '[fF]\"(?:\\\\\\\\.|[^\"\\\\\\\\\\\\n])*\"',\n            },\n            token: \"string\",\n          },\n          {\n            match: {\n              kind: \"pattern\",\n              regex: \"[fF]'(?:\\\\\\\\.|[^'\\\\\\\\\\\\n])*'\",\n            },\n            token: \"string\",\n          },\n          // Raw strings\n          {\n            match: {\n              kind: \"pattern\",\n              regex: '[rRbB]{1,2}\"(?:\\\\\\\\.|[^\"\\\\\\\\])*\"',\n            },\n            token: \"string\",\n          },\n          {\n            match: {\n              kind: \"pattern\",\n              regex: \"[rRbB]{1,2}'(?:\\\\\\\\.|[^'\\\\\\\\])*'\",\n            },\n            token: \"string\",\n          },\n          // Regular strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Decorators\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"@\" },\n                {\n                  kind: \"charSequence\",\n                  first: { ref: \"identStart\" },\n                  rest: {\n                    union: [{ predefined: \"alphanumeric\" }, { chars: \"_.\" }],\n                  },\n                },\n              ],\n            },\n            token: \"decorator\",\n          },\n          // Numbers\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              hex: true,\n              binary: true,\n              octal: true,\n              scientific: true,\n              separator: \"_\",\n            },\n            token: \"number\",\n          },\n          // Keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"and\", \"as\", \"assert\", \"async\", \"await\", \"break\", \"class\",\n                \"continue\", \"def\", \"del\", \"elif\", \"else\", \"except\",\n                \"finally\", \"for\", \"from\", \"global\", \"if\", \"import\", \"in\",\n                \"is\", \"lambda\", \"nonlocal\", \"not\", \"or\", \"pass\", \"raise\",\n                \"return\", \"try\", \"while\", \"with\", \"yield\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          // Constants\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\"True\", \"False\", \"None\"],\n            },\n            token: \"constant\",\n          },\n          // Built-in functions\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"print\", \"len\", \"range\", \"int\", \"str\", \"float\", \"list\",\n                \"dict\", \"set\", \"tuple\", \"type\", \"isinstance\", \"issubclass\",\n                \"super\", \"property\", \"staticmethod\", \"classmethod\",\n                \"enumerate\", \"zip\", \"map\", \"filter\", \"sorted\", \"reversed\",\n                \"abs\", \"min\", \"max\", \"sum\", \"any\", \"all\", \"open\", \"input\",\n                \"hasattr\", \"getattr\", \"setattr\", \"delattr\", \"vars\", \"dir\",\n              ],\n            },\n            token: \"builtin\",\n          },\n          // Type-like identifiers (PascalCase)\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { range: [\"A\", \"Z\"] },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"type_name\",\n          },\n          // Identifiers\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          // Multi-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \"**=\", \"//=\", \"<<=\", \">>=\", \"**\", \"//\", \"<<\", \">>\",\n                \"<=\", \">=\", \"==\", \"!=\", \"+=\", \"-=\", \"*=\", \"/=\",\n                \"%=\", \"&=\", \"|=\", \"^=\", \"->\", \":=\",\n              ],\n            },\n            token: \"operator\",\n          },\n          // Single-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"<\", \">\", \"&\", \"|\", \"^\", \"~\", \"@\"],\n            },\n            token: \"operator\",\n          },\n          // Punctuation\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \":\", \";\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n      fstring_single: {\n        rules: [\n          // Expression hole\n          {\n            match: { kind: \"string\", value: \"{\" },\n            token: \"fstring_expr\",\n            push: \"default\",\n          },\n          // End of f-string\n          {\n            match: { kind: \"string\", value: ['\"', \"'\"] },\n            token: \"fstring_start\",\n            pop: true,\n          },\n        ],\n      },\n      fstring_triple: {\n        rules: [\n          {\n            match: { kind: \"string\", value: \"{\" },\n            token: \"fstring_expr\",\n            push: \"default\",\n          },\n          {\n            match: { kind: \"string\", value: ['\"\"\"', \"'''\"] },\n            token: \"fstring_start\",\n            pop: true,\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [\n      { name: \"braces\", open: \"{\", close: \"}\" },\n      { name: \"parens\", open: \"(\", close: \")\" },\n      { name: \"brackets\", open: \"[\", close: \"]\" },\n    ],\n    symbols: [\n      {\n        name: \"function_definition\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"def\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"indentation\",\n      },\n      {\n        name: \"async_function_definition\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"async\" },\n          { token: \"keyword\", value: \"def\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"indentation\",\n      },\n      {\n        name: \"class_definition\",\n        kind: \"class\",\n        pattern: [\n          { token: \"keyword\", value: \"class\" },\n          {\n            anyOf: [\n              { token: \"identifier\", capture: \"name\" },\n              { token: \"type_name\", capture: \"name\" },\n            ],\n          },\n        ],\n        hasBody: true,\n        bodyStyle: \"indentation\",\n      },\n      {\n        name: \"decorated_definition\",\n        kind: \"decorator\",\n        pattern: [{ token: \"decorator\", capture: \"name\" }],\n        hasBody: false,\n      },\n      {\n        name: \"import_statement\",\n        kind: \"import\",\n        pattern: [{ token: \"keyword\", value: \"import\" }],\n        hasBody: false,\n      },\n      {\n        name: \"import_from_statement\",\n        kind: \"import\",\n        pattern: [\n          { token: \"keyword\", value: \"from\" },\n          { skip: true, maxTokens: 10 },\n          { token: \"keyword\", value: \"import\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"assignment\",\n        kind: \"variable\",\n        pattern: [\n          { token: \"identifier\", capture: \"name\" },\n          { token: \"operator\", value: \"=\" },\n        ],\n        hasBody: false,\n      },\n    ],\n  },\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** Go language profile - Level 1 (Lexer) + Level 2 (Structure) */\nexport const go: LanguageProfile = {\n  name: \"go\",\n  displayName: \"Go\",\n  version: \"1.0.0\",\n  fileExtensions: [\".go\"],\n  mimeTypes: [\"text/x-go\"],\n\n  lexer: {\n    charClasses: {\n      identStart: {\n        union: [{ predefined: \"letter\" }, { chars: \"_\" }],\n      },\n      identPart: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"_\" }],\n      },\n    },\n    tokenTypes: {\n      keyword: { category: \"keyword\" },\n      constant: { category: \"constant\" },\n      builtin: { category: \"keyword\", subcategory: \"builtin\" },\n      identifier: { category: \"identifier\" },\n      type_name: { category: \"type\" },\n      type_keyword: { category: \"type\", subcategory: \"builtin\" },\n      string: { category: \"string\" },\n      rune: { category: \"string\", subcategory: \"rune\" },\n      number: { category: \"number\" },\n      comment: { category: \"comment\" },\n      operator: { category: \"operator\" },\n      punctuation: { category: \"punctuation\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [\"whitespace\", \"newline\", \"comment\"],\n    states: {\n      default: {\n        rules: [\n          // Block comments\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"/*\",\n              close: \"*/\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          // Line comments\n          { match: { kind: \"line\", start: \"//\" }, token: \"comment\" },\n          // Raw strings (backtick)\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"`\",\n              close: \"`\",\n              multiline: true,\n            },\n            token: \"string\",\n          },\n          // Interpreted strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Rune literals\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"rune\",\n          },\n          // Numbers\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              hex: true,\n              octal: true,\n              binary: true,\n              scientific: true,\n              separator: \"_\",\n            },\n            token: \"number\",\n          },\n          // Keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"break\", \"case\", \"chan\", \"const\", \"continue\", \"default\",\n                \"defer\", \"else\", \"fallthrough\", \"for\", \"func\", \"go\",\n                \"goto\", \"if\", \"import\", \"interface\", \"map\", \"package\",\n                \"range\", \"return\", \"select\", \"struct\", \"switch\", \"type\",\n                \"var\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          // Constants\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\"true\", \"false\", \"nil\", \"iota\"],\n            },\n            token: \"constant\",\n          },\n          // Built-in functions\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"append\", \"cap\", \"clear\", \"close\", \"complex\", \"copy\",\n                \"delete\", \"imag\", \"len\", \"make\", \"max\", \"min\", \"new\",\n                \"panic\", \"print\", \"println\", \"real\", \"recover\",\n              ],\n            },\n            token: \"builtin\",\n          },\n          // Built-in types\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"bool\", \"byte\", \"complex64\", \"complex128\", \"error\",\n                \"float32\", \"float64\", \"int\", \"int8\", \"int16\", \"int32\",\n                \"int64\", \"rune\", \"string\", \"uint\", \"uint8\", \"uint16\",\n                \"uint32\", \"uint64\", \"uintptr\", \"any\", \"comparable\",\n              ],\n            },\n            token: \"type_keyword\",\n          },\n          // Type-like identifiers (PascalCase / exported)\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { range: [\"A\", \"Z\"] },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"type_name\",\n          },\n          // Identifiers\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          // Multi-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \":=\", \"<-\", \"<<\", \">>\", \"&^\", \"&&\", \"||\",\n                \"<=\", \">=\", \"==\", \"!=\", \"+=\", \"-=\", \"*=\", \"/=\",\n                \"%=\", \"&=\", \"|=\", \"^=\", \"<<=\", \">>=\", \"&^=\",\n                \"++\", \"--\", \"...\",\n              ],\n            },\n            token: \"operator\",\n          },\n          // Single-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"<\", \">\", \"&\", \"|\", \"^\", \"!\", \"~\"],\n            },\n            token: \"operator\",\n          },\n          // Punctuation\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \";\", \":\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [\n      { name: \"braces\", open: \"{\", close: \"}\" },\n      { name: \"parens\", open: \"(\", close: \")\" },\n      { name: \"brackets\", open: \"[\", close: \"]\" },\n    ],\n    symbols: [\n      {\n        name: \"function_declaration\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"func\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"method_declaration\",\n        kind: \"method\",\n        pattern: [\n          { token: \"keyword\", value: \"func\" },\n          { token: \"punctuation\", value: \"(\" },\n          { skip: true, maxTokens: 10 },\n          { token: \"punctuation\", value: \")\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"type_declaration\",\n        kind: \"type\",\n        pattern: [\n          { token: \"keyword\", value: \"type\" },\n          { token: \"type_name\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"interface_declaration\",\n        kind: \"interface\",\n        pattern: [\n          { token: \"keyword\", value: \"type\" },\n          { token: \"type_name\", capture: \"name\" },\n          { token: \"keyword\", value: \"interface\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"struct_declaration\",\n        kind: \"class\",\n        pattern: [\n          { token: \"keyword\", value: \"type\" },\n          { token: \"type_name\", capture: \"name\" },\n          { token: \"keyword\", value: \"struct\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"import_declaration\",\n        kind: \"import\",\n        pattern: [{ token: \"keyword\", value: \"import\" }],\n        hasBody: false,\n      },\n      {\n        name: \"var_declaration\",\n        kind: \"variable\",\n        pattern: [\n          { token: \"keyword\", value: \"var\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"const_declaration\",\n        kind: \"constant\",\n        pattern: [\n          { token: \"keyword\", value: \"const\" },\n          {\n            anyOf: [\n              { token: \"identifier\", capture: \"name\" },\n              { token: \"punctuation\", value: \"(\" },\n            ],\n          },\n        ],\n        hasBody: false,\n      },\n    ],\n    folding: [\n      { open: { token: \"punctuation\", value: \"{\" }, close: { token: \"punctuation\", value: \"}\" } },\n    ],\n  },\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** JavaScript language profile - Level 1 (Lexer) + Level 2 (Structure) */\nexport const javascript: LanguageProfile = {\n  name: \"javascript\",\n  displayName: \"JavaScript\",\n  version: \"1.0.0\",\n  fileExtensions: [\".js\", \".mjs\", \".cjs\", \".jsx\"],\n  mimeTypes: [\"text/javascript\", \"application/javascript\"],\n\n  lexer: {\n    charClasses: {\n      identStart: {\n        union: [{ predefined: \"letter\" }, { chars: \"_$\" }],\n      },\n      identPart: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"_$\" }],\n      },\n    },\n    tokenTypes: {\n      keyword: { category: \"keyword\" },\n      constant: { category: \"constant\" },\n      identifier: { category: \"identifier\" },\n      type_name: { category: \"type\" },\n      string: { category: \"string\" },\n      template_start: { category: \"string\", subcategory: \"template\" },\n      template_content: { category: \"string\", subcategory: \"template\" },\n      template_expr_open: {\n        category: \"punctuation\",\n        subcategory: \"template\",\n      },\n      template_end: { category: \"string\", subcategory: \"template\" },\n      number: { category: \"number\" },\n      comment: { category: \"comment\" },\n      regexp: { category: \"regexp\" },\n      operator: { category: \"operator\" },\n      punctuation: { category: \"punctuation\" },\n      jsx_tag_open: { category: \"tag\" },\n      jsx_tag_close: { category: \"tag\" },\n      jsx_tag_end: { category: \"tag\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [\"whitespace\", \"newline\", \"comment\"],\n    states: {\n      default: {\n        rules: [\n          // Block comments\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"/*\",\n              close: \"*/\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          // Line comments\n          { match: { kind: \"line\", start: \"//\" }, token: \"comment\" },\n          // Template strings\n          {\n            match: { kind: \"string\", value: \"`\" },\n            token: \"template_start\",\n            push: \"template_string\",\n          },\n          // Strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Numbers\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              hex: true,\n              binary: true,\n              octal: true,\n              scientific: true,\n              separator: \"_\",\n            },\n            token: \"number\",\n          },\n          // Keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\",\n                \"debugger\", \"default\", \"delete\", \"do\", \"else\", \"export\",\n                \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\",\n                \"in\", \"instanceof\", \"let\", \"new\", \"return\", \"super\",\n                \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\",\n                \"void\", \"while\", \"with\", \"yield\", \"async\", \"await\", \"of\",\n                \"static\", \"get\", \"set\", \"from\", \"as\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          // Constants\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\"true\", \"false\", \"null\", \"undefined\", \"NaN\", \"Infinity\"],\n            },\n            token: \"constant\",\n          },\n          // Type-like identifiers (PascalCase)\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { range: [\"A\", \"Z\"] },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"type_name\",\n          },\n          // Identifiers\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          // Multi-char operators (longest match first)\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \">>>=\", \"<<=\", \">>=\", \"**=\", \"&&=\", \"||=\", \"??=\",\n                \"===\", \"!==\", \">>>\", \"...\",\n                \"==\", \"!=\", \">=\", \"<=\", \"&&\", \"||\", \"??\", \"?.\",\n                \"**\", \"++\", \"--\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n                \"&=\", \"|=\", \"^=\", \"=>\", \"<<\", \">>\",\n              ],\n            },\n            token: \"operator\",\n          },\n          // Single-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"!\", \"<\", \">\",\n                \"&\", \"|\", \"^\", \"~\", \"?\", \":\",\n              ],\n            },\n            token: \"operator\",\n          },\n          // Punctuation\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \";\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n      template_string: {\n        rules: [\n          // Expression hole ${\n          {\n            match: { kind: \"string\", value: \"${\" },\n            token: \"template_expr_open\",\n            push: \"template_expr\",\n          },\n          // End of template string\n          {\n            match: { kind: \"string\", value: \"`\" },\n            token: \"template_end\",\n            pop: true,\n          },\n          // Template content: any chars (handled by engine consuming until ` or ${)\n        ],\n      },\n      template_expr: {\n        rules: [\n          // Closing brace ends expression, return to template string\n          {\n            match: { kind: \"string\", value: \"}\" },\n            token: \"punctuation\",\n            pop: true,\n          },\n          // Nested template string inside expression\n          {\n            match: { kind: \"string\", value: \"`\" },\n            token: \"template_start\",\n            push: \"template_string\",\n          },\n          // Block comments\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"/*\",\n              close: \"*/\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          // Line comments\n          { match: { kind: \"line\", start: \"//\" }, token: \"comment\" },\n          // Strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Numbers\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              hex: true,\n              binary: true,\n              octal: true,\n              scientific: true,\n              separator: \"_\",\n            },\n            token: \"number\",\n          },\n          // Keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\",\n                \"debugger\", \"default\", \"delete\", \"do\", \"else\", \"export\",\n                \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\",\n                \"in\", \"instanceof\", \"let\", \"new\", \"return\", \"super\",\n                \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\",\n                \"void\", \"while\", \"with\", \"yield\", \"async\", \"await\", \"of\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          // Constants\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\"true\", \"false\", \"null\", \"undefined\", \"NaN\", \"Infinity\"],\n            },\n            token: \"constant\",\n          },\n          // Identifiers\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          // Operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \"===\", \"!==\", \"==\", \"!=\", \">=\", \"<=\", \"&&\", \"||\", \"??\",\n                \"?.\", \"**\", \"++\", \"--\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n                \"=>\", \"<<\", \">>\", \">>>\", \"...\",\n              ],\n            },\n            token: \"operator\",\n          },\n          {\n            match: {\n              kind: \"string\",\n              value: [\"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"!\", \"<\", \">\", \"&\", \"|\", \"^\", \"~\", \"?\", \":\"],\n            },\n            token: \"operator\",\n          },\n          // Punctuation (but NOT }, which is handled above)\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"(\", \")\", \"[\", \"]\", \";\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          // Nested braces: push another template_expr to track brace depth\n          // (handled by engine via block tracking)\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [\n      { name: \"braces\", open: \"{\", close: \"}\" },\n      { name: \"parens\", open: \"(\", close: \")\" },\n      { name: \"brackets\", open: \"[\", close: \"]\" },\n    ],\n    symbols: [\n      {\n        name: \"function_declaration\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"function\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"async_function_declaration\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"async\" },\n          { token: \"keyword\", value: \"function\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"class_declaration\",\n        kind: \"class\",\n        pattern: [\n          { token: \"keyword\", value: \"class\" },\n          {\n            anyOf: [\n              { token: \"identifier\", capture: \"name\" },\n              { token: \"type_name\", capture: \"name\" },\n            ],\n          },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"arrow_function_const\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"const\" },\n          { token: \"identifier\", capture: \"name\" },\n          { token: \"operator\", value: \"=\" },\n          { skip: true, maxTokens: 30 },\n          { token: \"operator\", value: \"=>\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"arrow_function_let\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"let\" },\n          { token: \"identifier\", capture: \"name\" },\n          { token: \"operator\", value: \"=\" },\n          { skip: true, maxTokens: 30 },\n          { token: \"operator\", value: \"=>\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"lexical_declaration\",\n        kind: \"variable\",\n        pattern: [\n          {\n            anyOf: [\n              { token: \"keyword\", value: \"const\" },\n              { token: \"keyword\", value: \"let\" },\n            ],\n          },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"variable_declaration\",\n        kind: \"variable\",\n        pattern: [\n          { token: \"keyword\", value: \"var\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"import_statement\",\n        kind: \"import\",\n        pattern: [{ token: \"keyword\", value: \"import\" }],\n        hasBody: false,\n      },\n      {\n        name: \"export_statement\",\n        kind: \"export\",\n        pattern: [{ token: \"keyword\", value: \"export\" }],\n        hasBody: false,\n      },\n    ],\n    folding: [\n      { open: { token: \"punctuation\", value: \"{\" }, close: { token: \"punctuation\", value: \"}\" } },\n      { open: { token: \"comment\" }, close: { token: \"comment\" } },\n    ],\n  },\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/**\n * TypeScript language profile - extends JavaScript.\n * Adds type annotations, generics, interfaces, enums, decorators, etc.\n * Level 1 (Lexer) + Level 2 (Structure)\n */\nexport const typescript: LanguageProfile = {\n  name: \"typescript\",\n  displayName: \"TypeScript\",\n  version: \"1.0.0\",\n  fileExtensions: [\".ts\", \".mts\", \".cts\", \".tsx\"],\n  mimeTypes: [\"text/typescript\", \"application/typescript\"],\n  extends: \"javascript\",\n\n  lexer: {\n    charClasses: {\n      identStart: {\n        union: [{ predefined: \"letter\" }, { chars: \"_$\" }],\n      },\n      identPart: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"_$\" }],\n      },\n    },\n    tokenTypes: {\n      keyword: { category: \"keyword\" },\n      ts_keyword: { category: \"keyword\", subcategory: \"typescript\" },\n      constant: { category: \"constant\" },\n      identifier: { category: \"identifier\" },\n      type_name: { category: \"type\" },\n      decorator: { category: \"decorator\" },\n      string: { category: \"string\" },\n      template_start: { category: \"string\", subcategory: \"template\" },\n      template_content: { category: \"string\", subcategory: \"template\" },\n      template_expr_open: {\n        category: \"punctuation\",\n        subcategory: \"template\",\n      },\n      template_end: { category: \"string\", subcategory: \"template\" },\n      number: { category: \"number\" },\n      comment: { category: \"comment\" },\n      operator: { category: \"operator\" },\n      punctuation: { category: \"punctuation\" },\n      jsx_tag_open: { category: \"tag\" },\n      jsx_tag_close: { category: \"tag\" },\n      jsx_tag_end: { category: \"tag\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [\"whitespace\", \"newline\", \"comment\"],\n    states: {\n      default: {\n        rules: [\n          // Block comments\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"/*\",\n              close: \"*/\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          // Line comments\n          { match: { kind: \"line\", start: \"//\" }, token: \"comment\" },\n          // Template strings\n          {\n            match: { kind: \"string\", value: \"`\" },\n            token: \"template_start\",\n            push: \"template_string\",\n          },\n          // Strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Decorators\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \"@\" },\n                {\n                  kind: \"charSequence\",\n                  first: { ref: \"identStart\" },\n                  rest: {\n                    union: [{ predefined: \"alphanumeric\" }, { chars: \"_$.\" }],\n                  },\n                },\n              ],\n            },\n            token: \"decorator\",\n          },\n          // Numbers\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              hex: true,\n              binary: true,\n              octal: true,\n              scientific: true,\n              separator: \"_\",\n            },\n            token: \"number\",\n          },\n          // TypeScript-specific keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"interface\", \"type\", \"enum\", \"namespace\", \"module\",\n                \"declare\", \"abstract\", \"implements\", \"readonly\",\n                \"public\", \"private\", \"protected\", \"override\",\n                \"keyof\", \"infer\", \"is\", \"asserts\", \"satisfies\",\n                \"as\", \"unknown\", \"never\", \"any\",\n              ],\n            },\n            token: \"ts_keyword\",\n          },\n          // JavaScript keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\",\n                \"debugger\", \"default\", \"delete\", \"do\", \"else\", \"export\",\n                \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\",\n                \"in\", \"instanceof\", \"let\", \"new\", \"return\", \"super\",\n                \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\",\n                \"void\", \"while\", \"with\", \"yield\", \"async\", \"await\", \"of\",\n                \"static\", \"get\", \"set\", \"from\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          // Constants\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\"true\", \"false\", \"null\", \"undefined\", \"NaN\", \"Infinity\"],\n            },\n            token: \"constant\",\n          },\n          // Type-like identifiers (PascalCase)\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { range: [\"A\", \"Z\"] },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"type_name\",\n          },\n          // Identifiers\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          // Multi-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \">>>=\", \"<<=\", \">>=\", \"**=\", \"&&=\", \"||=\", \"??=\",\n                \"===\", \"!==\", \">>>\", \"...\",\n                \"==\", \"!=\", \">=\", \"<=\", \"&&\", \"||\", \"??\", \"?.\",\n                \"**\", \"++\", \"--\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n                \"&=\", \"|=\", \"^=\", \"=>\", \"<<\", \">>\",\n              ],\n            },\n            token: \"operator\",\n          },\n          // Single-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"!\", \"<\", \">\",\n                \"&\", \"|\", \"^\", \"~\", \"?\", \":\",\n              ],\n            },\n            token: \"operator\",\n          },\n          // Punctuation\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \";\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n      template_string: {\n        rules: [\n          {\n            match: { kind: \"string\", value: \"${\" },\n            token: \"template_expr_open\",\n            push: \"template_expr\",\n          },\n          {\n            match: { kind: \"string\", value: \"`\" },\n            token: \"template_end\",\n            pop: true,\n          },\n        ],\n      },\n      template_expr: {\n        rules: [\n          {\n            match: { kind: \"string\", value: \"}\" },\n            token: \"punctuation\",\n            pop: true,\n          },\n          {\n            match: { kind: \"string\", value: \"`\" },\n            token: \"template_start\",\n            push: \"template_string\",\n          },\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"/*\",\n              close: \"*/\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          { match: { kind: \"line\", start: \"//\" }, token: \"comment\" },\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              hex: true,\n              binary: true,\n              octal: true,\n              scientific: true,\n              separator: \"_\",\n            },\n            token: \"number\",\n          },\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\",\n                \"delete\", \"do\", \"else\", \"export\", \"extends\", \"finally\",\n                \"for\", \"function\", \"if\", \"import\", \"in\", \"instanceof\",\n                \"let\", \"new\", \"return\", \"super\", \"switch\", \"this\",\n                \"throw\", \"try\", \"typeof\", \"var\", \"void\", \"while\",\n                \"with\", \"yield\", \"async\", \"await\", \"of\",\n                \"interface\", \"type\", \"enum\", \"as\", \"keyof\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\"true\", \"false\", \"null\", \"undefined\"],\n            },\n            token: \"constant\",\n          },\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \"===\", \"!==\", \"==\", \"!=\", \">=\", \"<=\", \"&&\", \"||\", \"??\",\n                \"?.\", \"**\", \"++\", \"--\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n                \"=>\", \"<<\", \">>\", \">>>\", \"...\",\n              ],\n            },\n            token: \"operator\",\n          },\n          {\n            match: {\n              kind: \"string\",\n              value: [\"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"!\", \"<\", \">\", \"&\", \"|\", \"^\", \"~\", \"?\", \":\"],\n            },\n            token: \"operator\",\n          },\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"(\", \")\", \"[\", \"]\", \";\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [\n      { name: \"braces\", open: \"{\", close: \"}\" },\n      { name: \"parens\", open: \"(\", close: \")\" },\n      { name: \"brackets\", open: \"[\", close: \"]\" },\n    ],\n    symbols: [\n      {\n        name: \"function_declaration\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"function\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"async_function_declaration\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"async\" },\n          { token: \"keyword\", value: \"function\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"class_declaration\",\n        kind: \"class\",\n        pattern: [\n          { token: \"keyword\", value: \"class\" },\n          {\n            anyOf: [\n              { token: \"identifier\", capture: \"name\" },\n              { token: \"type_name\", capture: \"name\" },\n            ],\n          },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"abstract_class_declaration\",\n        kind: \"class\",\n        pattern: [\n          { token: \"ts_keyword\", value: \"abstract\" },\n          { token: \"keyword\", value: \"class\" },\n          {\n            anyOf: [\n              { token: \"identifier\", capture: \"name\" },\n              { token: \"type_name\", capture: \"name\" },\n            ],\n          },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"interface_declaration\",\n        kind: \"interface\",\n        pattern: [\n          { token: \"ts_keyword\", value: \"interface\" },\n          { token: \"type_name\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"type_alias_declaration\",\n        kind: \"type\",\n        pattern: [\n          { token: \"ts_keyword\", value: \"type\" },\n          { token: \"type_name\", capture: \"name\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"enum_declaration\",\n        kind: \"enum\",\n        pattern: [\n          { token: \"ts_keyword\", value: \"enum\" },\n          {\n            anyOf: [\n              { token: \"identifier\", capture: \"name\" },\n              { token: \"type_name\", capture: \"name\" },\n            ],\n          },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"namespace_declaration\",\n        kind: \"namespace\",\n        pattern: [\n          { token: \"ts_keyword\", value: \"namespace\" },\n          {\n            anyOf: [\n              { token: \"identifier\", capture: \"name\" },\n              { token: \"type_name\", capture: \"name\" },\n            ],\n          },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"arrow_function_const\",\n        kind: \"function\",\n        pattern: [\n          { token: \"keyword\", value: \"const\" },\n          { token: \"identifier\", capture: \"name\" },\n          { token: \"operator\", value: \"=\" },\n          { skip: true, maxTokens: 50 },\n          { token: \"operator\", value: \"=>\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"lexical_declaration\",\n        kind: \"variable\",\n        pattern: [\n          {\n            anyOf: [\n              { token: \"keyword\", value: \"const\" },\n              { token: \"keyword\", value: \"let\" },\n            ],\n          },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"variable_declaration\",\n        kind: \"variable\",\n        pattern: [\n          { token: \"keyword\", value: \"var\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"import_statement\",\n        kind: \"import\",\n        pattern: [{ token: \"keyword\", value: \"import\" }],\n        hasBody: false,\n      },\n      {\n        name: \"export_statement\",\n        kind: \"export\",\n        pattern: [{ token: \"keyword\", value: \"export\" }],\n        hasBody: false,\n      },\n    ],\n    folding: [\n      { open: { token: \"punctuation\", value: \"{\" }, close: { token: \"punctuation\", value: \"}\" } },\n    ],\n  },\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** C++ language profile - Level 1 (Lexer) + Level 2 (Structure) */\nexport const cpp: LanguageProfile = {\n  name: \"cpp\",\n  displayName: \"C++\",\n  version: \"1.0.0\",\n  fileExtensions: [\".cpp\", \".hpp\", \".cc\", \".hh\", \".cxx\", \".hxx\", \".h\"],\n  mimeTypes: [\"text/x-c++src\"],\n\n  lexer: {\n    charClasses: {\n      identStart: {\n        union: [{ predefined: \"letter\" }, { chars: \"_\" }],\n      },\n      identPart: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"_\" }],\n      },\n    },\n    tokenTypes: {\n      keyword: { category: \"keyword\" },\n      type_keyword: { category: \"type\", subcategory: \"builtin\" },\n      constant: { category: \"constant\" },\n      identifier: { category: \"identifier\" },\n      type_name: { category: \"type\" },\n      preprocessor: { category: \"meta\", subcategory: \"preprocessor\" },\n      string: { category: \"string\" },\n      char_literal: { category: \"string\", subcategory: \"char\" },\n      raw_string: { category: \"string\", subcategory: \"raw\" },\n      number: { category: \"number\" },\n      comment: { category: \"comment\" },\n      operator: { category: \"operator\" },\n      punctuation: { category: \"punctuation\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [\"whitespace\", \"newline\", \"comment\"],\n    states: {\n      default: {\n        rules: [\n          // Block comments\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"/*\",\n              close: \"*/\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          // Line comments\n          { match: { kind: \"line\", start: \"//\" }, token: \"comment\" },\n          // Preprocessor directives\n          { match: { kind: \"line\", start: \"#\" }, token: \"preprocessor\" },\n          // Raw strings R\"delimiter(content)delimiter\"\n          {\n            match: {\n              kind: \"pattern\",\n              regex: 'R\"([^(\\\\s]*)\\\\([\\\\s\\\\S]*?\\\\)\\\\1\"',\n            },\n            token: \"raw_string\",\n          },\n          // Regular strings\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Character literals\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"char_literal\",\n          },\n          // Numbers\n          {\n            match: {\n              kind: \"number\",\n              integer: true,\n              float: true,\n              hex: true,\n              octal: true,\n              binary: true,\n              scientific: true,\n              separator: \"'\",\n              suffix: [\"u\", \"U\", \"l\", \"L\", \"ll\", \"LL\", \"ul\", \"UL\", \"ull\", \"ULL\", \"f\", \"F\"],\n            },\n            token: \"number\",\n          },\n          // C++ keywords\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"alignas\", \"alignof\", \"and\", \"and_eq\", \"asm\", \"auto\",\n                \"bitand\", \"bitor\", \"break\", \"case\", \"catch\", \"class\",\n                \"compl\", \"concept\", \"const\", \"consteval\", \"constexpr\",\n                \"constinit\", \"const_cast\", \"continue\", \"co_await\",\n                \"co_return\", \"co_yield\", \"decltype\", \"default\", \"delete\",\n                \"do\", \"dynamic_cast\", \"else\", \"enum\", \"explicit\",\n                \"export\", \"extern\", \"for\", \"friend\", \"goto\", \"if\",\n                \"inline\", \"mutable\", \"namespace\", \"new\", \"noexcept\",\n                \"not\", \"not_eq\", \"operator\", \"or\", \"or_eq\", \"private\",\n                \"protected\", \"public\", \"register\", \"reinterpret_cast\",\n                \"requires\", \"return\", \"sizeof\", \"static\", \"static_assert\",\n                \"static_cast\", \"struct\", \"switch\", \"template\", \"this\",\n                \"throw\", \"try\", \"typedef\", \"typeid\", \"typename\", \"union\",\n                \"using\", \"virtual\", \"volatile\", \"while\", \"xor\", \"xor_eq\",\n                \"override\", \"final\",\n              ],\n            },\n            token: \"keyword\",\n          },\n          // Built-in types\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\n                \"void\", \"bool\", \"char\", \"char8_t\", \"char16_t\", \"char32_t\",\n                \"wchar_t\", \"short\", \"int\", \"long\", \"float\", \"double\",\n                \"signed\", \"unsigned\", \"size_t\", \"ptrdiff_t\", \"nullptr_t\",\n                \"int8_t\", \"int16_t\", \"int32_t\", \"int64_t\",\n                \"uint8_t\", \"uint16_t\", \"uint32_t\", \"uint64_t\",\n              ],\n            },\n            token: \"type_keyword\",\n          },\n          // Constants\n          {\n            match: {\n              kind: \"keywords\",\n              words: [\"true\", \"false\", \"nullptr\", \"NULL\"],\n            },\n            token: \"constant\",\n          },\n          // Type-like identifiers (PascalCase)\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { range: [\"A\", \"Z\"] },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"type_name\",\n          },\n          // Identifiers\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { ref: \"identStart\" },\n              rest: { ref: \"identPart\" },\n            },\n            token: \"identifier\",\n          },\n          // Multi-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\n                \"<<=\", \">>=\", \"<=>\", \"->*\",\n                \"==\", \"!=\", \">=\", \"<=\", \"&&\", \"||\", \"<<\", \">>\",\n                \"++\", \"--\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n                \"&=\", \"|=\", \"^=\", \"->\", \"::\", \".*\", \"...\",\n              ],\n            },\n            token: \"operator\",\n          },\n          // Single-char operators\n          {\n            match: {\n              kind: \"string\",\n              value: [\"+\", \"-\", \"*\", \"/\", \"%\", \"=\", \"!\", \"<\", \">\", \"&\", \"|\", \"^\", \"~\", \"?\", \":\"],\n            },\n            token: \"operator\",\n          },\n          // Punctuation\n          {\n            match: {\n              kind: \"string\",\n              value: [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \";\", \",\", \".\"],\n            },\n            token: \"punctuation\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [\n      { name: \"braces\", open: \"{\", close: \"}\" },\n      { name: \"parens\", open: \"(\", close: \")\" },\n      { name: \"brackets\", open: \"[\", close: \"]\" },\n    ],\n    symbols: [\n      {\n        name: \"function_definition\",\n        kind: \"function\",\n        pattern: [\n          {\n            anyOf: [\n              { token: \"type_keyword\" },\n              { token: \"type_name\" },\n              { token: \"identifier\" },\n            ],\n          },\n          { token: \"identifier\", capture: \"name\" },\n          { token: \"punctuation\", value: \"(\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"class_specifier\",\n        kind: \"class\",\n        pattern: [\n          { token: \"keyword\", value: \"class\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"struct_specifier\",\n        kind: \"class\",\n        pattern: [\n          { token: \"keyword\", value: \"struct\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"enum_specifier\",\n        kind: \"enum\",\n        pattern: [\n          { token: \"keyword\", value: \"enum\" },\n          { optional: { token: \"keyword\", value: \"class\" } },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"namespace_definition\",\n        kind: \"namespace\",\n        pattern: [\n          { token: \"keyword\", value: \"namespace\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: true,\n        bodyStyle: \"braces\",\n      },\n      {\n        name: \"template_declaration\",\n        kind: \"typeParameter\",\n        pattern: [\n          { token: \"keyword\", value: \"template\" },\n          { token: \"operator\", value: \"<\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"typedef_declaration\",\n        kind: \"type\",\n        pattern: [{ token: \"keyword\", value: \"typedef\" }],\n        hasBody: false,\n      },\n      {\n        name: \"using_declaration\",\n        kind: \"type\",\n        pattern: [\n          { token: \"keyword\", value: \"using\" },\n          { token: \"identifier\", capture: \"name\" },\n        ],\n        hasBody: false,\n      },\n    ],\n    folding: [\n      { open: { token: \"punctuation\", value: \"{\" }, close: { token: \"punctuation\", value: \"}\" } },\n      { open: { token: \"preprocessor\" }, close: { token: \"preprocessor\" } },\n    ],\n  },\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** HTML language profile - Level 1 (Lexer) + Level 2 (Structure) + Embedded Languages */\nexport const html: LanguageProfile = {\n  name: \"html\",\n  displayName: \"HTML\",\n  version: \"1.0.0\",\n  fileExtensions: [\".html\", \".htm\"],\n  mimeTypes: [\"text/html\"],\n\n  lexer: {\n    charClasses: {\n      tagNameChar: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"-_\" }],\n      },\n      attrNameChar: {\n        union: [{ predefined: \"alphanumeric\" }, { chars: \"-_:.\" }],\n      },\n    },\n    tokenTypes: {\n      comment: { category: \"comment\" },\n      doctype: { category: \"meta\", subcategory: \"doctype\" },\n      tag_open: { category: \"tag\" },\n      tag_close: { category: \"tag\" },\n      tag_self_close: { category: \"tag\" },\n      tag_name: { category: \"tag\", subcategory: \"name\" },\n      attr_name: { category: \"attribute\" },\n      attr_eq: { category: \"operator\" },\n      string: { category: \"string\" },\n      text: { category: \"plain\" },\n      entity: { category: \"escape\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"content\",\n    skipTokens: [\"whitespace\", \"newline\"],\n    states: {\n      content: {\n        rules: [\n          // HTML comments\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"<!--\",\n              close: \"-->\",\n              multiline: true,\n            },\n            token: \"comment\",\n          },\n          // DOCTYPE\n          {\n            match: {\n              kind: \"pattern\",\n              regex: \"<!DOCTYPE[^>]*>\",\n            },\n            token: \"doctype\",\n          },\n          // Closing tag\n          {\n            match: { kind: \"string\", value: \"</\" },\n            token: \"tag_close\",\n            push: \"tag\",\n          },\n          // Opening tag\n          {\n            match: { kind: \"string\", value: \"<\" },\n            token: \"tag_open\",\n            push: \"tag\",\n          },\n          // HTML entities\n          {\n            match: {\n              kind: \"pattern\",\n              regex: \"&(?:#[0-9]+|#x[0-9a-fA-F]+|[a-zA-Z]+);\",\n            },\n            token: \"entity\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n          // Text content (any non-tag, non-entity content)\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { negate: { chars: \"<&\" } },\n              rest: { negate: { chars: \"<&\" } },\n            },\n            token: \"text\",\n          },\n        ],\n      },\n      tag: {\n        rules: [\n          // Self-closing tag end\n          {\n            match: { kind: \"string\", value: \"/>\" },\n            token: \"tag_self_close\",\n            pop: true,\n          },\n          // Tag end\n          {\n            match: { kind: \"string\", value: \">\" },\n            token: \"tag_open\",\n            pop: true,\n          },\n          // Tag name\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"letter\" },\n              rest: { ref: \"tagNameChar\" },\n            },\n            token: \"tag_name\",\n          },\n          // Attribute name\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"letter\" },\n              rest: { ref: \"attrNameChar\" },\n            },\n            token: \"attr_name\",\n          },\n          // Attribute =\n          { match: { kind: \"string\", value: \"=\" }, token: \"attr_eq\" },\n          // Attribute values\n          {\n            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\n            token: \"string\",\n          },\n          {\n            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\n            token: \"string\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [],\n    symbols: [\n      {\n        name: \"doctype\",\n        kind: \"doctype\",\n        pattern: [{ token: \"doctype\", capture: \"name\" }],\n        hasBody: false,\n      },\n      {\n        name: \"element\",\n        kind: \"element\",\n        pattern: [\n          { token: \"tag_open\", value: \"<\" },\n          { token: \"tag_name\", capture: \"name\" },\n        ],\n        hasBody: false,\n      },\n      {\n        name: \"entity\",\n        kind: \"entity\",\n        pattern: [{ token: \"entity\", capture: \"name\" }],\n        hasBody: false,\n      },\n    ],\n  },\n\n  embeddedLanguages: [\n    {\n      language: \"css\",\n      start: { token: \"tag_name\", value: \"style\" },\n      end: { token: \"tag_close\" },\n      languageDetection: \"fixed\",\n    },\n    {\n      language: \"javascript\",\n      start: { token: \"tag_name\", value: \"script\" },\n      end: { token: \"tag_close\" },\n      languageDetection: \"attribute\",\n      attributeToken: \"string\",\n    },\n  ],\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\n\n/** Markdown language profile - Level 1 (Lexer) + Level 2 (Structure) */\nexport const markdown: LanguageProfile = {\n  name: \"markdown\",\n  displayName: \"Markdown\",\n  version: \"1.0.0\",\n  fileExtensions: [\".md\", \".markdown\", \".mdx\"],\n  mimeTypes: [\"text/markdown\"],\n\n  lexer: {\n    tokenTypes: {\n      heading: { category: \"heading\" },\n      code_fence_open: { category: \"meta\", subcategory: \"code-fence\" },\n      code_fence_close: { category: \"meta\", subcategory: \"code-fence\" },\n      code_content: { category: \"string\", subcategory: \"code\" },\n      code_language: { category: \"identifier\", subcategory: \"language\" },\n      inline_code: { category: \"string\", subcategory: \"inline-code\" },\n      bold: { category: \"keyword\", subcategory: \"bold\" },\n      italic: { category: \"keyword\", subcategory: \"italic\" },\n      link_text: { category: \"link\", subcategory: \"text\" },\n      link_url: { category: \"link\", subcategory: \"url\" },\n      image_marker: { category: \"keyword\", subcategory: \"image\" },\n      list_marker: { category: \"punctuation\", subcategory: \"list\" },\n      table_separator: { category: \"punctuation\", subcategory: \"table-separator\" },\n      table_row: { category: \"meta\", subcategory: \"table-row\" },\n      blockquote: { category: \"punctuation\", subcategory: \"blockquote\" },\n      hr: { category: \"punctuation\", subcategory: \"hr\" },\n      html_tag: { category: \"tag\" },\n      text: { category: \"plain\" },\n      whitespace: { category: \"whitespace\" },\n      newline: { category: \"newline\" },\n    },\n    initialState: \"default\",\n    skipTokens: [],\n    states: {\n      default: {\n        rules: [\n          // Fenced code block open (``` or ~~~)\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: [\"```\", \"~~~\"] },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"letter\" },\n                  rest: {\n                    union: [{ predefined: \"alphanumeric\" }, { chars: \"-_+.\" }],\n                  },\n                },\n              ],\n            },\n            token: \"code_fence_open\",\n            push: \"code_block\",\n          },\n          // Fenced code block without language\n          {\n            match: { kind: \"string\", value: [\"```\", \"~~~\"] },\n            token: \"code_fence_open\",\n            push: \"code_block\",\n          },\n          // Headings (# through ######)\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: [\"######\", \"#####\", \"####\", \"###\", \"##\", \"#\"] },\n                { kind: \"charSequence\", first: { predefined: \"whitespace\" } },\n              ],\n            },\n            token: \"heading\",\n          },\n          // Inline code\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"``\",\n              close: \"``\",\n            },\n            token: \"inline_code\",\n          },\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"`\",\n              close: \"`\",\n            },\n            token: \"inline_code\",\n          },\n          // Bold\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"**\",\n              close: \"**\",\n            },\n            token: \"bold\",\n          },\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"__\",\n              close: \"__\",\n            },\n            token: \"bold\",\n          },\n          // Italic\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"*\",\n              close: \"*\",\n            },\n            token: \"italic\",\n          },\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"_\",\n              close: \"_\",\n            },\n            token: \"italic\",\n          },\n          // Image\n          {\n            match: { kind: \"string\", value: \"![\" },\n            token: \"image_marker\",\n          },\n          // Link text [text](url)\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"[\",\n              close: \"]\",\n            },\n            token: \"link_text\",\n          },\n          {\n            match: {\n              kind: \"delimited\",\n              open: \"(\",\n              close: \")\",\n            },\n            token: \"link_url\",\n          },\n          // Horizontal rule\n          {\n            match: { kind: \"string\", value: [\"---\", \"***\", \"___\"] },\n            token: \"hr\",\n          },\n          // Table separator row\n          {\n            match: {\n              kind: \"pattern\",\n              regex: \"\\\\|?\\\\s*:?-{3,}:?\\\\s*(?:\\\\|\\\\s*:?-{3,}:?\\\\s*)+\\\\|?\",\n            },\n            token: \"table_separator\",\n          },\n          // Table row\n          {\n            match: {\n              kind: \"pattern\",\n              regex: \"\\\\|[^\\\\n]*\\\\|\",\n            },\n            token: \"table_row\",\n          },\n          // Blockquote\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: \">\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"whitespace\" },\n                },\n              ],\n            },\n            token: \"blockquote\",\n          },\n          // Unordered list markers\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                { kind: \"string\", value: [\"-\", \"*\", \"+\"] },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"whitespace\" },\n                },\n              ],\n            },\n            token: \"list_marker\",\n          },\n          // Ordered list markers (1. 2. etc.)\n          {\n            match: {\n              kind: \"sequence\",\n              elements: [\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"digit\" },\n                  rest: { predefined: \"digit\" },\n                },\n                { kind: \"string\", value: \".\" },\n                {\n                  kind: \"charSequence\",\n                  first: { predefined: \"whitespace\" },\n                },\n              ],\n            },\n            token: \"list_marker\",\n          },\n          // HTML inline tags\n          {\n            match: {\n              kind: \"pattern\",\n              regex: \"</?[a-zA-Z][a-zA-Z0-9-]*[^>]*>\",\n            },\n            token: \"html_tag\",\n          },\n          // Whitespace\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"whitespace\" },\n              rest: { predefined: \"whitespace\" },\n            },\n            token: \"whitespace\",\n          },\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n          // Text (any remaining content)\n          {\n            match: {\n              kind: \"charSequence\",\n              first: {\n                negate: {\n                  union: [\n                    { predefined: \"whitespace\" },\n                    { predefined: \"newline\" },\n                  ],\n                },\n              },\n              rest: {\n                negate: {\n                  union: [\n                    { chars: \"`*_[](!)#>-+\" },\n                    { predefined: \"newline\" },\n                  ],\n                },\n              },\n            },\n            token: \"text\",\n          },\n        ],\n      },\n      code_block: {\n        rules: [\n          // Close fence\n          {\n            match: { kind: \"string\", value: [\"```\", \"~~~\"] },\n            token: \"code_fence_close\",\n            pop: true,\n          },\n          // Code content (any line)\n          {\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\n            token: \"newline\",\n          },\n          {\n            match: {\n              kind: \"charSequence\",\n              first: { predefined: \"any\" },\n              rest: { negate: { predefined: \"newline\" } },\n            },\n            token: \"code_content\",\n          },\n        ],\n      },\n    },\n  },\n\n  structure: {\n    blocks: [],\n    symbols: [\n      {\n        name: \"heading\",\n        kind: \"heading\",\n        pattern: [{ token: \"heading\", capture: \"name\" }],\n        hasBody: false,\n      },\n      {\n        name: \"code_block\",\n        kind: \"codeBlock\",\n        pattern: [{ token: \"code_fence_open\", capture: \"name\" }],\n        hasBody: true,\n        bodyStyle: \"markup-block\",\n      },\n      {\n        name: \"code_span\",\n        kind: \"codeBlock\",\n        pattern: [{ token: \"inline_code\", capture: \"name\" }],\n        hasBody: false,\n      },\n      {\n        name: \"list_item\",\n        kind: \"listItem\",\n        pattern: [{ token: \"list_marker\", capture: \"name\" }],\n        hasBody: true,\n        bodyStyle: \"markup-block\",\n      },\n      {\n        name: \"table\",\n        kind: \"table\",\n        pattern: [{ token: \"table_row\", capture: \"name\" }],\n        hasBody: true,\n        bodyStyle: \"markup-block\",\n      },\n      {\n        name: \"blockquote\",\n        kind: \"blockquote\",\n        pattern: [{ token: \"blockquote\", capture: \"name\" }],\n        hasBody: true,\n        bodyStyle: \"markup-block\",\n      },\n      {\n        name: \"link\",\n        kind: \"link\",\n        pattern: [{ token: \"link_url\", capture: \"name\" }],\n        hasBody: false,\n      },\n      {\n        name: \"image\",\n        kind: \"image\",\n        pattern: [{ token: \"image_marker\", capture: \"name\" }],\n        hasBody: false,\n      },\n    ],\n  },\n\n  embeddedLanguages: [\n    {\n      language: \"javascript\",\n      start: { token: \"code_fence_open\", value: \"```javascript\" },\n      end: { token: \"code_fence_close\" },\n      languageDetection: \"attribute\",\n      attributeToken: \"code_language\",\n    },\n  ],\n};\n","import type { LanguageProfile } from \"../schema/profile.js\";\r\n\r\ninterface GenericCodeProfileOptions {\r\n    name: string;\r\n    displayName: string;\r\n    fileExtensions: string[];\r\n    mimeTypes?: string[];\r\n    keywords?: string[];\r\n    lineComment?: string;\r\n    blockComment?: { open: string; close: string; nested?: boolean };\r\n    stringDelimiters?: Array<'\"' | \"'\" | \"`\">;\r\n}\r\n\r\ninterface MarkupProfileOptions {\r\n    name: string;\r\n    displayName: string;\r\n    fileExtensions: string[];\r\n    mimeTypes?: string[];\r\n}\r\n\r\n/**\r\n * Generic, lexer-focused profile for common programming languages.\r\n * Prioritizes robust tokenization over deep grammar/structure.\r\n */\r\nexport function createGenericCodeProfile(\r\n    options: GenericCodeProfileOptions,\r\n): LanguageProfile {\r\n    const {\r\n        name,\r\n        displayName,\r\n        fileExtensions,\r\n        mimeTypes,\r\n        keywords = [],\r\n        lineComment,\r\n        blockComment,\r\n        stringDelimiters = ['\"', \"'\"],\r\n    } = options;\r\n\r\n    const keywordSet = new Set(keywords.map((keyword) => keyword.toLowerCase()));\r\n\r\n    const classKeywords = [\"class\", \"object\"];\r\n    const structKeywords = [\"struct\"];\r\n    const interfaceKeywords = [\"interface\", \"trait\", \"protocol\"];\r\n    const enumKeywords = [\"enum\"];\r\n    const functionKeywords = [\"function\", \"fn\", \"def\", \"fun\", \"func\", \"sub\"];\r\n    const packageKeywords = [\"package\"];\r\n    const namespaceKeywords = [\"namespace\"];\r\n    const moduleKeywords = [\"module\", \"mod\"];\r\n    const typeKeywords = [\"type\", \"typealias\", \"typedef\"];\r\n    const variableKeywords = [\"var\", \"let\", \"val\"];\r\n    const constantKeywords = [\"const\", \"readonly\"];\r\n    const importKeywords = [\"import\", \"use\", \"require\", \"require_once\", \"include\", \"include_once\", \"using\"];\r\n    const exportKeywords = [\"export\"];\r\n    const sqlObjectKeywords = [\r\n        \"table\",\r\n        \"view\",\r\n        \"function\",\r\n        \"procedure\",\r\n        \"trigger\",\r\n        \"index\",\r\n        \"schema\",\r\n        \"database\",\r\n    ];\r\n\r\n    const availableClassKeywords = classKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableStructKeywords = structKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableInterfaceKeywords = interfaceKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableEnumKeywords = enumKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableFunctionKeywords = functionKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availablePackageKeywords = packageKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableNamespaceKeywords = namespaceKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableModuleKeywords = moduleKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableTypeKeywords = typeKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableVariableKeywords = variableKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableConstantKeywords = constantKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableImportKeywords = importKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const availableExportKeywords = exportKeywords.filter((keyword) => keywordSet.has(keyword));\r\n    const hasSqlCreate = keywordSet.has(\"create\") && sqlObjectKeywords.some((keyword) => keywordSet.has(keyword));\r\n\r\n    const symbols: NonNullable<LanguageProfile[\"structure\"]>[\"symbols\"] = [];\r\n\r\n    if (availableClassKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"class_declaration\",\r\n            kind: \"class\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableClassKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableStructKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"struct_declaration\",\r\n            kind: \"struct\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableStructKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableInterfaceKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"interface_declaration\",\r\n            kind: \"interface\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableInterfaceKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableEnumKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"enum_declaration\",\r\n            kind: \"enum\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableEnumKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableFunctionKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"function_declaration\",\r\n            kind: \"function\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableFunctionKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableNamespaceKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"namespace_declaration\",\r\n            kind: \"namespace\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableNamespaceKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availablePackageKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"package_declaration\",\r\n            kind: \"package\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availablePackageKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableModuleKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"module_declaration\",\r\n            kind: \"module\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableModuleKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableTypeKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"type_declaration\",\r\n            kind: \"type\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableTypeKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableVariableKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"variable_declaration\",\r\n            kind: \"variable\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableVariableKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableConstantKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"constant_declaration\",\r\n            kind: \"constant\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableConstantKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableImportKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"import_statement\",\r\n            kind: \"import\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableImportKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (availableExportKeywords.length > 0) {\r\n        symbols.push({\r\n            name: \"export_statement\",\r\n            kind: \"export\",\r\n            pattern: [\r\n                {\r\n                    anyOf: availableExportKeywords.map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    if (hasSqlCreate) {\r\n        const sqlCreateObjects: Array<{\r\n            keyword: string;\r\n            kind: \"table\" | \"view\" | \"function\" | \"procedure\" | \"trigger\" | \"index\" | \"schema\" | \"database\";\r\n            name: string;\r\n        }> = [\r\n                { keyword: \"table\", kind: \"table\", name: \"create_table_statement\" },\r\n                { keyword: \"view\", kind: \"view\", name: \"create_view_statement\" },\r\n                { keyword: \"function\", kind: \"function\", name: \"create_function_statement\" },\r\n                { keyword: \"procedure\", kind: \"procedure\", name: \"create_procedure_statement\" },\r\n                { keyword: \"trigger\", kind: \"trigger\", name: \"create_trigger_statement\" },\r\n                { keyword: \"index\", kind: \"index\", name: \"create_index_statement\" },\r\n                { keyword: \"schema\", kind: \"schema\", name: \"create_schema_statement\" },\r\n                { keyword: \"database\", kind: \"database\", name: \"create_database_statement\" },\r\n            ];\r\n\r\n        for (const sqlObject of sqlCreateObjects) {\r\n            if (!keywordSet.has(sqlObject.keyword)) {\r\n                continue;\r\n            }\r\n\r\n            symbols.push({\r\n                name: sqlObject.name,\r\n                kind: sqlObject.kind,\r\n                pattern: [\r\n                    { token: \"keyword\", value: \"create\" },\r\n                    {\r\n                        optional: {\r\n                            anyOf: [\r\n                                { token: \"keyword\", value: \"or\" },\r\n                                { token: \"keyword\", value: \"replace\" },\r\n                            ],\r\n                        },\r\n                    },\r\n                    {\r\n                        optional: {\r\n                            anyOf: [\r\n                                { token: \"keyword\", value: \"or\" },\r\n                                { token: \"keyword\", value: \"replace\" },\r\n                            ],\r\n                        },\r\n                    },\r\n                    { token: \"keyword\", value: sqlObject.keyword },\r\n                    { token: \"identifier\", capture: \"name\" },\r\n                ],\r\n                hasBody: false,\r\n            });\r\n        }\r\n\r\n        symbols.push({\r\n            name: \"create_statement\",\r\n            kind: \"object\",\r\n            pattern: [\r\n                { token: \"keyword\", value: \"create\" },\r\n                {\r\n                    optional: {\r\n                        anyOf: [\r\n                            { token: \"keyword\", value: \"or\" },\r\n                            { token: \"keyword\", value: \"replace\" },\r\n                        ],\r\n                    },\r\n                },\r\n                {\r\n                    optional: {\r\n                        anyOf: [\r\n                            { token: \"keyword\", value: \"or\" },\r\n                            { token: \"keyword\", value: \"replace\" },\r\n                        ],\r\n                    },\r\n                },\r\n                {\r\n                    anyOf: sqlObjectKeywords\r\n                        .filter((keyword) => keywordSet.has(keyword))\r\n                        .map((keyword) => ({ token: \"keyword\", value: keyword })),\r\n                },\r\n                { token: \"identifier\", capture: \"name\" },\r\n            ],\r\n            hasBody: false,\r\n        });\r\n    }\r\n\r\n    const rules: LanguageProfile[\"lexer\"][\"states\"][\"default\"][\"rules\"] = [];\r\n\r\n    if (blockComment) {\r\n        rules.push({\r\n            match: {\r\n                kind: \"delimited\",\r\n                open: blockComment.open,\r\n                close: blockComment.close,\r\n                multiline: true,\r\n                nested: blockComment.nested ?? false,\r\n            },\r\n            token: \"comment\",\r\n        });\r\n    }\r\n\r\n    if (lineComment) {\r\n        rules.push({\r\n            match: { kind: \"line\", start: lineComment },\r\n            token: \"comment\",\r\n        });\r\n    }\r\n\r\n    for (const delimiter of stringDelimiters) {\r\n        rules.push({\r\n            match: { kind: \"delimited\", open: delimiter, close: delimiter, escape: \"\\\\\" },\r\n            token: \"string\",\r\n        });\r\n    }\r\n\r\n    rules.push({\r\n        match: {\r\n            kind: \"number\",\r\n            integer: true,\r\n            float: true,\r\n            scientific: true,\r\n            hex: true,\r\n            octal: true,\r\n            binary: true,\r\n            separator: \"_\",\r\n        },\r\n        token: \"number\",\r\n    });\r\n\r\n    if (keywords.length > 0) {\r\n        rules.push({\r\n            match: { kind: \"keywords\", words: keywords },\r\n            token: \"keyword\",\r\n        });\r\n    }\r\n\r\n    rules.push(\r\n        {\r\n            match: {\r\n                kind: \"charSequence\",\r\n                first: { ref: \"identStart\" },\r\n                rest: { ref: \"identPart\" },\r\n            },\r\n            token: \"identifier\",\r\n        },\r\n        {\r\n            match: {\r\n                kind: \"string\",\r\n                value: [\r\n                    \"===\",\r\n                    \"!==\",\r\n                    \"==\",\r\n                    \"!=\",\r\n                    \"<=\",\r\n                    \">=\",\r\n                    \"=>\",\r\n                    \"->\",\r\n                    \"::\",\r\n                    \"&&\",\r\n                    \"||\",\r\n                    \"??\",\r\n                    \"+\",\r\n                    \"-\",\r\n                    \"*\",\r\n                    \"/\",\r\n                    \"%\",\r\n                    \"=\",\r\n                    \"<\",\r\n                    \">\",\r\n                    \"!\",\r\n                    \"&\",\r\n                    \"|\",\r\n                    \"^\",\r\n                    \"~\",\r\n                    \"?\",\r\n                    \":\",\r\n                    \".\",\r\n                ],\r\n            },\r\n            token: \"operator\",\r\n        },\r\n        {\r\n            match: {\r\n                kind: \"string\",\r\n                value: [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \",\", \";\"],\r\n            },\r\n            token: \"punctuation\",\r\n        },\r\n        {\r\n            match: {\r\n                kind: \"charSequence\",\r\n                first: { predefined: \"whitespace\" },\r\n                rest: { predefined: \"whitespace\" },\r\n            },\r\n            token: \"whitespace\",\r\n        },\r\n        {\r\n            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\r\n            token: \"newline\",\r\n        },\r\n        {\r\n            match: {\r\n                kind: \"charSequence\",\r\n                first: { predefined: \"any\" },\r\n                rest: { negate: { predefined: \"newline\" } },\r\n            },\r\n            token: \"text\",\r\n        },\r\n    );\r\n\r\n    return {\r\n        name,\r\n        displayName,\r\n        version: \"1.0.0\",\r\n        fileExtensions,\r\n        mimeTypes,\r\n        lexer: {\r\n            charClasses: {\r\n                identStart: {\r\n                    union: [{ predefined: \"letter\" }, { chars: \"_$\" }],\r\n                },\r\n                identPart: {\r\n                    union: [{ predefined: \"alphanumeric\" }, { chars: \"_$\" }],\r\n                },\r\n            },\r\n            tokenTypes: {\r\n                comment: { category: \"comment\" },\r\n                string: { category: \"string\" },\r\n                number: { category: \"number\" },\r\n                keyword: { category: \"keyword\" },\r\n                identifier: { category: \"identifier\" },\r\n                operator: { category: \"operator\" },\r\n                punctuation: { category: \"punctuation\" },\r\n                text: { category: \"plain\" },\r\n                whitespace: { category: \"whitespace\" },\r\n                newline: { category: \"newline\" },\r\n            },\r\n            initialState: \"default\",\r\n            skipTokens: [\"whitespace\", \"newline\"],\r\n            states: {\r\n                default: {\r\n                    rules,\r\n                },\r\n            },\r\n        },\r\n        structure: {\r\n            blocks: [{ name: \"braces\", open: \"{\", close: \"}\" }],\r\n            symbols,\r\n        },\r\n    };\r\n}\r\n\r\n/**\r\n * Generic XML-like markup profile.\r\n */\r\nexport function createMarkupProfile(options: MarkupProfileOptions): LanguageProfile {\r\n    return {\r\n        name: options.name,\r\n        displayName: options.displayName,\r\n        version: \"1.0.0\",\r\n        fileExtensions: options.fileExtensions,\r\n        mimeTypes: options.mimeTypes,\r\n        lexer: {\r\n            charClasses: {\r\n                tagNameChar: {\r\n                    union: [{ predefined: \"alphanumeric\" }, { chars: \"-_:\" }],\r\n                },\r\n            },\r\n            tokenTypes: {\r\n                comment: { category: \"comment\" },\r\n                cdata: { category: \"string\", subcategory: \"cdata\" },\r\n                processing: { category: \"meta\", subcategory: \"processing\" },\r\n                tag_open: { category: \"tag\" },\r\n                tag_close: { category: \"tag\" },\r\n                tag_name: { category: \"tag\", subcategory: \"name\" },\r\n                string: { category: \"string\" },\r\n                operator: { category: \"operator\" },\r\n                text: { category: \"plain\" },\r\n                whitespace: { category: \"whitespace\" },\r\n                newline: { category: \"newline\" },\r\n            },\r\n            initialState: \"content\",\r\n            skipTokens: [\"whitespace\", \"newline\"],\r\n            states: {\r\n                content: {\r\n                    rules: [\r\n                        {\r\n                            match: {\r\n                                kind: \"delimited\",\r\n                                open: \"<!--\",\r\n                                close: \"-->\",\r\n                                multiline: true,\r\n                            },\r\n                            token: \"comment\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"delimited\",\r\n                                open: \"<![CDATA[\",\r\n                                close: \"]]>\",\r\n                                multiline: true,\r\n                            },\r\n                            token: \"cdata\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"delimited\",\r\n                                open: \"<?\",\r\n                                close: \"?>\",\r\n                                multiline: true,\r\n                            },\r\n                            token: \"processing\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"string\", value: \"</\" },\r\n                            token: \"tag_close\",\r\n                            push: \"tag\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"string\", value: \"<\" },\r\n                            token: \"tag_open\",\r\n                            push: \"tag\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"charSequence\",\r\n                                first: { predefined: \"whitespace\" },\r\n                                rest: { predefined: \"whitespace\" },\r\n                            },\r\n                            token: \"whitespace\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\r\n                            token: \"newline\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"charSequence\",\r\n                                first: { negate: { chars: \"<\" } },\r\n                                rest: { negate: { chars: \"<\" } },\r\n                            },\r\n                            token: \"text\",\r\n                        },\r\n                    ],\r\n                },\r\n                tag: {\r\n                    rules: [\r\n                        {\r\n                            match: { kind: \"string\", value: [\"/>\", \">\"] },\r\n                            token: \"tag_open\",\r\n                            pop: true,\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"charSequence\",\r\n                                first: { predefined: \"letter\" },\r\n                                rest: { ref: \"tagNameChar\" },\r\n                            },\r\n                            token: \"tag_name\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"string\", value: \"=\" },\r\n                            token: \"operator\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\r\n                            token: \"string\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\r\n                            token: \"string\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"charSequence\",\r\n                                first: { predefined: \"whitespace\" },\r\n                                rest: { predefined: \"whitespace\" },\r\n                            },\r\n                            token: \"whitespace\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\r\n                            token: \"newline\",\r\n                        },\r\n                    ],\r\n                },\r\n            },\r\n        },\r\n        structure: {\r\n            blocks: [],\r\n            symbols: [\r\n                {\r\n                    name: \"element\",\r\n                    kind: \"element\",\r\n                    pattern: [\r\n                        { token: \"tag_open\", value: \"<\" },\r\n                        { token: \"tag_name\", capture: \"name\" },\r\n                    ],\r\n                    hasBody: false,\r\n                },\r\n                {\r\n                    name: \"processing_instruction\",\r\n                    kind: \"processingInstruction\",\r\n                    pattern: [{ token: \"processing\", capture: \"name\" }],\r\n                    hasBody: false,\r\n                },\r\n                {\r\n                    name: \"cdata\",\r\n                    kind: \"cdata\",\r\n                    pattern: [{ token: \"cdata\", capture: \"name\" }],\r\n                    hasBody: false,\r\n                },\r\n            ],\r\n        },\r\n    };\r\n}\r\n\r\n/**\r\n * Basic YAML profile.\r\n */\r\nexport function createYamlProfile(\r\n    name: string,\r\n    displayName: string,\r\n    fileExtensions: string[],\r\n    mimeTypes?: string[],\r\n): LanguageProfile {\r\n    return {\r\n        name,\r\n        displayName,\r\n        version: \"1.0.0\",\r\n        fileExtensions,\r\n        mimeTypes,\r\n        lexer: {\r\n            charClasses: {\r\n                keyStart: {\r\n                    union: [{ predefined: \"letter\" }, { chars: \"_-\" }],\r\n                },\r\n                keyPart: {\r\n                    union: [{ predefined: \"alphanumeric\" }, { chars: \"_-.\" }],\r\n                },\r\n            },\r\n            tokenTypes: {\r\n                comment: { category: \"comment\" },\r\n                key: { category: \"key\" },\r\n                string: { category: \"string\" },\r\n                number: { category: \"number\" },\r\n                constant: { category: \"constant\" },\r\n                indicator: { category: \"punctuation\" },\r\n                indent: { category: \"whitespace\" },\r\n                dedent: { category: \"whitespace\" },\r\n                whitespace: { category: \"whitespace\" },\r\n                newline: { category: \"newline\" },\r\n                text: { category: \"plain\" },\r\n            },\r\n            initialState: \"default\",\r\n            skipTokens: [\"whitespace\", \"newline\", \"indent\", \"dedent\"],\r\n            indentation: {\r\n                indentToken: \"indent\",\r\n                dedentToken: \"dedent\",\r\n                unit: \"spaces\",\r\n                size: 2,\r\n            },\r\n            states: {\r\n                default: {\r\n                    rules: [\r\n                        { match: { kind: \"line\", start: \"#\" }, token: \"comment\" },\r\n                        { match: { kind: \"string\", value: [\"---\", \"...\", \"-\", \":\", \"?\", \"|\"] }, token: \"indicator\" },\r\n                        {\r\n                            match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\r\n                            token: \"string\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"delimited\", open: \"'\", close: \"'\", escape: \"\\\\\" },\r\n                            token: \"string\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"number\",\r\n                                integer: true,\r\n                                float: true,\r\n                                scientific: true,\r\n                            },\r\n                            token: \"number\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"keywords\",\r\n                                words: [\"true\", \"false\", \"null\", \"yes\", \"no\", \"on\", \"off\"],\r\n                            },\r\n                            token: \"constant\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"charSequence\",\r\n                                first: { ref: \"keyStart\" },\r\n                                rest: { ref: \"keyPart\" },\r\n                            },\r\n                            token: \"key\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"charSequence\",\r\n                                first: { predefined: \"whitespace\" },\r\n                                rest: { predefined: \"whitespace\" },\r\n                            },\r\n                            token: \"whitespace\",\r\n                        },\r\n                        {\r\n                            match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\r\n                            token: \"newline\",\r\n                        },\r\n                        {\r\n                            match: {\r\n                                kind: \"charSequence\",\r\n                                first: { predefined: \"any\" },\r\n                                rest: { negate: { predefined: \"newline\" } },\r\n                            },\r\n                            token: \"text\",\r\n                        },\r\n                    ],\r\n                },\r\n            },\r\n        },\r\n        structure: {\r\n            blocks: [],\r\n            symbols: [\r\n                {\r\n                    name: \"document_separator\",\r\n                    kind: \"directive\",\r\n                    pattern: [{ token: \"indicator\", value: \"---\" }],\r\n                    hasBody: false,\r\n                },\r\n                {\r\n                    name: \"document_end\",\r\n                    kind: \"directive\",\r\n                    pattern: [{ token: \"indicator\", value: \"...\" }],\r\n                    hasBody: false,\r\n                },\r\n                {\r\n                    name: \"mapping_pair\",\r\n                    kind: \"pair\",\r\n                    pattern: [\r\n                        { token: \"key\", capture: \"name\" },\r\n                        { token: \"indicator\", value: \":\" },\r\n                    ],\r\n                    hasBody: false,\r\n                },\r\n                {\r\n                    name: \"sequence_item\",\r\n                    kind: \"listItem\",\r\n                    pattern: [{ token: \"indicator\", value: \"-\" }],\r\n                    hasBody: false,\r\n                },\r\n                {\r\n                    name: \"string_value\",\r\n                    kind: \"string\",\r\n                    pattern: [{ token: \"string\", capture: \"name\" }],\r\n                    hasBody: false,\r\n                },\r\n                {\r\n                    name: \"number_value\",\r\n                    kind: \"number\",\r\n                    pattern: [{ token: \"number\", capture: \"name\" }],\r\n                    hasBody: false,\r\n                },\r\n                {\r\n                    name: \"constant_value\",\r\n                    kind: \"constant\",\r\n                    pattern: [{ token: \"constant\", capture: \"name\" }],\r\n                    hasBody: false,\r\n                },\r\n            ],\r\n        },\r\n    };\r\n}\r\n","import { createYamlProfile } from \"./common.js\";\r\n\r\nexport const yaml = createYamlProfile(\r\n    \"yaml\",\r\n    \"YAML\",\r\n    [\".yaml\", \".yml\"],\r\n    [\"application/x-yaml\", \"text/yaml\"],\r\n);\r\n","import { createMarkupProfile } from \"./common.js\";\r\n\r\nexport const xml = createMarkupProfile({\r\n    name: \"xml\",\r\n    displayName: \"XML\",\r\n    fileExtensions: [\".xml\", \".xsd\", \".xsl\", \".xslt\", \".svg\"],\r\n    mimeTypes: [\"application/xml\", \"text/xml\", \"image/svg+xml\"],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const java = createGenericCodeProfile({\r\n    name: \"java\",\r\n    displayName: \"Java\",\r\n    fileExtensions: [\".java\"],\r\n    mimeTypes: [\"text/x-java-source\", \"text/java\"],\r\n    lineComment: \"//\",\r\n    blockComment: { open: \"/*\", close: \"*/\" },\r\n    keywords: [\r\n        \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\", \"catch\", \"char\",\r\n        \"class\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"enum\",\r\n        \"extends\", \"final\", \"finally\", \"float\", \"for\", \"if\", \"implements\", \"import\",\r\n        \"instanceof\", \"int\", \"interface\", \"long\", \"native\", \"new\", \"package\", \"private\",\r\n        \"protected\", \"public\", \"return\", \"short\", \"static\", \"strictfp\", \"super\", \"switch\",\r\n        \"synchronized\", \"this\", \"throw\", \"throws\", \"transient\", \"try\", \"void\", \"volatile\", \"while\",\r\n    ],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const csharp = createGenericCodeProfile({\r\n    name: \"csharp\",\r\n    displayName: \"C#\",\r\n    fileExtensions: [\".cs\", \".csx\"],\r\n    mimeTypes: [\"text/x-csharp\"],\r\n    lineComment: \"//\",\r\n    blockComment: { open: \"/*\", close: \"*/\" },\r\n    stringDelimiters: ['\"', \"'\", \"`\"],\r\n    keywords: [\r\n        \"abstract\", \"as\", \"base\", \"bool\", \"break\", \"byte\", \"case\", \"catch\", \"char\", \"checked\",\r\n        \"class\", \"const\", \"continue\", \"decimal\", \"default\", \"delegate\", \"do\", \"double\", \"else\", \"enum\",\r\n        \"event\", \"explicit\", \"extern\", \"false\", \"finally\", \"fixed\", \"float\", \"for\", \"foreach\", \"goto\",\r\n        \"if\", \"implicit\", \"in\", \"int\", \"interface\", \"internal\", \"is\", \"lock\", \"long\", \"namespace\", \"new\",\r\n        \"null\", \"object\", \"operator\", \"out\", \"override\", \"params\", \"private\", \"protected\", \"public\", \"readonly\",\r\n        \"ref\", \"return\", \"sbyte\", \"sealed\", \"short\", \"sizeof\", \"stackalloc\", \"static\", \"string\", \"struct\",\r\n        \"switch\", \"this\", \"throw\", \"true\", \"try\", \"typeof\", \"uint\", \"ulong\", \"unchecked\", \"unsafe\", \"ushort\",\r\n        \"using\", \"virtual\", \"void\", \"volatile\", \"while\",\r\n    ],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const rust = createGenericCodeProfile({\r\n    name: \"rust\",\r\n    displayName: \"Rust\",\r\n    fileExtensions: [\".rs\"],\r\n    mimeTypes: [\"text/rust\"],\r\n    lineComment: \"//\",\r\n    blockComment: { open: \"/*\", close: \"*/\", nested: true },\r\n    keywords: [\r\n        \"as\", \"break\", \"const\", \"continue\", \"crate\", \"else\", \"enum\", \"extern\", \"false\", \"fn\",\r\n        \"for\", \"if\", \"impl\", \"in\", \"let\", \"loop\", \"match\", \"mod\", \"move\", \"mut\", \"pub\", \"ref\",\r\n        \"return\", \"self\", \"Self\", \"static\", \"struct\", \"super\", \"trait\", \"true\", \"type\", \"unsafe\",\r\n        \"use\", \"where\", \"while\", \"async\", \"await\", \"dyn\",\r\n    ],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const ruby = createGenericCodeProfile({\r\n    name: \"ruby\",\r\n    displayName: \"Ruby\",\r\n    fileExtensions: [\".rb\", \".rake\", \".gemspec\"],\r\n    mimeTypes: [\"application/x-ruby\"],\r\n    lineComment: \"#\",\r\n    keywords: [\r\n        \"BEGIN\", \"END\", \"alias\", \"and\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"defined?\", \"do\",\r\n        \"else\", \"elsif\", \"end\", \"ensure\", \"false\", \"for\", \"if\", \"in\", \"module\", \"next\", \"nil\", \"not\",\r\n        \"or\", \"redo\", \"rescue\", \"retry\", \"return\", \"self\", \"super\", \"then\", \"true\", \"undef\", \"unless\",\r\n        \"until\", \"when\", \"while\", \"yield\",\r\n    ],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const php = createGenericCodeProfile({\r\n    name: \"php\",\r\n    displayName: \"PHP\",\r\n    fileExtensions: [\".php\", \".phtml\", \".php8\"],\r\n    mimeTypes: [\"application/x-httpd-php\"],\r\n    lineComment: \"//\",\r\n    blockComment: { open: \"/*\", close: \"*/\" },\r\n    keywords: [\r\n        \"abstract\", \"and\", \"array\", \"as\", \"break\", \"callable\", \"case\", \"catch\", \"class\", \"clone\", \"const\",\r\n        \"continue\", \"declare\", \"default\", \"do\", \"echo\", \"else\", \"elseif\", \"empty\", \"enddeclare\", \"endfor\",\r\n        \"endforeach\", \"endif\", \"endswitch\", \"endwhile\", \"eval\", \"exit\", \"extends\", \"final\", \"finally\", \"fn\",\r\n        \"for\", \"foreach\", \"function\", \"global\", \"goto\", \"if\", \"implements\", \"include\", \"include_once\", \"instanceof\",\r\n        \"insteadof\", \"interface\", \"isset\", \"list\", \"match\", \"namespace\", \"new\", \"or\", \"print\", \"private\", \"protected\",\r\n        \"public\", \"readonly\", \"require\", \"require_once\", \"return\", \"static\", \"switch\", \"throw\", \"trait\", \"try\", \"unset\",\r\n        \"use\", \"var\", \"while\", \"xor\", \"yield\",\r\n    ],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const kotlin = createGenericCodeProfile({\r\n    name: \"kotlin\",\r\n    displayName: \"Kotlin\",\r\n    fileExtensions: [\".kt\", \".kts\"],\r\n    mimeTypes: [\"text/x-kotlin\"],\r\n    lineComment: \"//\",\r\n    blockComment: { open: \"/*\", close: \"*/\" },\r\n    keywords: [\r\n        \"as\", \"as?\", \"break\", \"class\", \"continue\", \"do\", \"else\", \"false\", \"for\", \"fun\", \"if\", \"in\",\r\n        \"interface\", \"is\", \"null\", \"object\", \"package\", \"return\", \"super\", \"this\", \"throw\", \"true\", \"try\",\r\n        \"typealias\", \"val\", \"var\", \"when\", \"while\", \"by\", \"catch\", \"constructor\", \"delegate\", \"dynamic\", \"field\",\r\n        \"file\", \"finally\", \"get\", \"import\", \"init\", \"param\", \"property\", \"receiver\", \"set\", \"setparam\", \"where\",\r\n    ],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const swift = createGenericCodeProfile({\r\n    name: \"swift\",\r\n    displayName: \"Swift\",\r\n    fileExtensions: [\".swift\"],\r\n    mimeTypes: [\"text/x-swift\"],\r\n    lineComment: \"//\",\r\n    blockComment: { open: \"/*\", close: \"*/\", nested: true },\r\n    keywords: [\r\n        \"associatedtype\", \"class\", \"deinit\", \"enum\", \"extension\", \"func\", \"import\", \"init\", \"inout\", \"internal\",\r\n        \"let\", \"operator\", \"private\", \"protocol\", \"public\", \"static\", \"struct\", \"subscript\", \"typealias\", \"var\",\r\n        \"break\", \"case\", \"continue\", \"default\", \"defer\", \"do\", \"else\", \"fallthrough\", \"for\", \"guard\", \"if\", \"in\",\r\n        \"repeat\", \"return\", \"switch\", \"where\", \"while\", \"as\", \"Any\", \"catch\", \"false\", \"is\", \"nil\", \"rethrows\",\r\n        \"super\", \"self\", \"Self\", \"throw\", \"throws\", \"true\", \"try\",\r\n    ],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const shell = createGenericCodeProfile({\r\n    name: \"shell\",\r\n    displayName: \"Shell\",\r\n    fileExtensions: [\".sh\", \".zsh\", \".ksh\"],\r\n    mimeTypes: [\"application/x-sh\"],\r\n    lineComment: \"#\",\r\n    keywords: [\r\n        \"if\", \"then\", \"else\", \"elif\", \"fi\", \"for\", \"while\", \"until\", \"do\", \"done\", \"case\", \"esac\", \"in\",\r\n        \"function\", \"select\", \"time\", \"coproc\", \"return\", \"break\", \"continue\", \"readonly\", \"local\", \"export\",\r\n    ],\r\n});\r\n","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const bash = createGenericCodeProfile({\r\n    name: \"bash\",\r\n    displayName: \"Bash\",\r\n    fileExtensions: [\".bash\"],\r\n    mimeTypes: [\"application/x-sh\"],\r\n    lineComment: \"#\",\r\n    keywords: [\r\n        \"if\", \"then\", \"else\", \"elif\", \"fi\", \"for\", \"while\", \"until\", \"do\", \"done\", \"case\", \"esac\", \"in\",\r\n        \"function\", \"select\", \"time\", \"coproc\", \"return\", \"break\", \"continue\", \"readonly\", \"local\", \"export\",\r\n    ],\r\n});","import { createGenericCodeProfile } from \"./common.js\";\r\n\r\nexport const sql = createGenericCodeProfile({\r\n    name: \"sql\",\r\n    displayName: \"SQL\",\r\n    fileExtensions: [\".sql\"],\r\n    mimeTypes: [\"application/sql\", \"text/x-sql\"],\r\n    lineComment: \"--\",\r\n    blockComment: { open: \"/*\", close: \"*/\" },\r\n    keywords: [\r\n        \"select\", \"from\", \"where\", \"insert\", \"into\", \"update\", \"delete\", \"create\", \"alter\", \"drop\", \"table\",\r\n        \"view\", \"index\", \"join\", \"left\", \"right\", \"inner\", \"outer\", \"on\", \"group\", \"by\", \"order\", \"having\",\r\n        \"limit\", \"offset\", \"union\", \"all\", \"distinct\", \"as\", \"and\", \"or\", \"not\", \"null\", \"is\", \"in\", \"exists\",\r\n        \"between\", \"like\", \"case\", \"when\", \"then\", \"else\", \"end\", \"primary\", \"key\", \"foreign\", \"references\",\r\n        \"constraint\", \"values\", \"set\", \"begin\", \"commit\", \"rollback\",\r\n    ],\r\n});\r\n","import type { LanguageProfile } from \"../schema/profile.js\";\r\n\r\nexport const toml: LanguageProfile = {\r\n    name: \"toml\",\r\n    displayName: \"TOML\",\r\n    version: \"1.0.0\",\r\n    fileExtensions: [\".toml\"],\r\n    mimeTypes: [\"application/toml\", \"text/toml\"],\r\n    lexer: {\r\n        charClasses: {\r\n            keyStart: {\r\n                union: [{ predefined: \"letter\" }, { chars: \"_-\" }],\r\n            },\r\n            keyPart: {\r\n                union: [{ predefined: \"alphanumeric\" }, { chars: \"_-\" }],\r\n            },\r\n        },\r\n        tokenTypes: {\r\n            comment: { category: \"comment\" },\r\n            datetime: { category: \"datetime\" },\r\n            key: { category: \"key\" },\r\n            string: { category: \"string\" },\r\n            number: { category: \"number\" },\r\n            constant: { category: \"constant\" },\r\n            operator: { category: \"operator\" },\r\n            punctuation: { category: \"punctuation\" },\r\n            whitespace: { category: \"whitespace\" },\r\n            newline: { category: \"newline\" },\r\n            text: { category: \"plain\" },\r\n        },\r\n        initialState: \"default\",\r\n        skipTokens: [\"whitespace\", \"newline\"],\r\n        states: {\r\n            default: {\r\n                rules: [\r\n                    { match: { kind: \"line\", start: \"#\" }, token: \"comment\" },\r\n                    {\r\n                        match: {\r\n                            kind: \"pattern\",\r\n                            regex:\r\n                                \"\\\\b\\\\d{4}-\\\\d{2}-\\\\d{2}(?:[Tt ]\\\\d{2}:\\\\d{2}:\\\\d{2}(?:\\\\.\\\\d+)?)?(?:[Zz]|[+-]\\\\d{2}:\\\\d{2})?\\\\b\",\r\n                        },\r\n                        token: \"datetime\",\r\n                    },\r\n                    {\r\n                        match: { kind: \"delimited\", open: '\"\"\"', close: '\"\"\"', multiline: true, escape: \"\\\\\" },\r\n                        token: \"string\",\r\n                    },\r\n                    {\r\n                        match: { kind: \"delimited\", open: \"'''\", close: \"'''\", multiline: true },\r\n                        token: \"string\",\r\n                    },\r\n                    {\r\n                        match: { kind: \"delimited\", open: '\"', close: '\"', escape: \"\\\\\" },\r\n                        token: \"string\",\r\n                    },\r\n                    {\r\n                        match: { kind: \"delimited\", open: \"'\", close: \"'\" },\r\n                        token: \"string\",\r\n                    },\r\n                    {\r\n                        match: {\r\n                            kind: \"number\",\r\n                            integer: true,\r\n                            float: true,\r\n                            scientific: true,\r\n                            hex: true,\r\n                            octal: true,\r\n                            binary: true,\r\n                            separator: \"_\",\r\n                        },\r\n                        token: \"number\",\r\n                    },\r\n                    {\r\n                        match: {\r\n                            kind: \"keywords\",\r\n                            words: [\"true\", \"false\"],\r\n                        },\r\n                        token: \"constant\",\r\n                    },\r\n                    {\r\n                        match: {\r\n                            kind: \"charSequence\",\r\n                            first: { ref: \"keyStart\" },\r\n                            rest: {\r\n                                union: [{ ref: \"keyPart\" }, { chars: \".\" }],\r\n                            },\r\n                        },\r\n                        token: \"key\",\r\n                    },\r\n                    {\r\n                        match: { kind: \"string\", value: \"=\" },\r\n                        token: \"operator\",\r\n                    },\r\n                    {\r\n                        match: { kind: \"string\", value: [\"[[\", \"]]\", \"[\", \"]\", \"{\", \"}\", \",\"] },\r\n                        token: \"punctuation\",\r\n                    },\r\n                    {\r\n                        match: {\r\n                            kind: \"charSequence\",\r\n                            first: { predefined: \"whitespace\" },\r\n                            rest: { predefined: \"whitespace\" },\r\n                        },\r\n                        token: \"whitespace\",\r\n                    },\r\n                    {\r\n                        match: { kind: \"charSequence\", first: { predefined: \"newline\" } },\r\n                        token: \"newline\",\r\n                    },\r\n                    {\r\n                        match: {\r\n                            kind: \"charSequence\",\r\n                            first: { predefined: \"any\" },\r\n                            rest: { negate: { predefined: \"newline\" } },\r\n                        },\r\n                        token: \"text\",\r\n                    },\r\n                ],\r\n            },\r\n        },\r\n    },\r\n    structure: {\r\n        blocks: [\r\n            { name: \"tables\", open: \"[\", close: \"]\" },\r\n            { name: \"inline-table\", open: \"{\", close: \"}\" },\r\n            { name: \"array\", open: \"[\", close: \"]\" },\r\n        ],\r\n        symbols: [\r\n            {\r\n                name: \"table\",\r\n                kind: \"table\",\r\n                pattern: [\r\n                    { token: \"punctuation\", value: \"[\" },\r\n                    { token: \"key\", capture: \"name\" },\r\n                    { token: \"punctuation\", value: \"]\" },\r\n                ],\r\n                hasBody: false,\r\n            },\r\n            {\r\n                name: \"array_table\",\r\n                kind: \"arrayTable\",\r\n                pattern: [\r\n                    { token: \"punctuation\", value: \"[[\" },\r\n                    { token: \"key\", capture: \"name\" },\r\n                    { token: \"punctuation\", value: \"]]\" },\r\n                ],\r\n                hasBody: false,\r\n            },\r\n            {\r\n                name: \"key_value\",\r\n                kind: \"pair\",\r\n                pattern: [\r\n                    { token: \"key\", capture: \"name\" },\r\n                    { token: \"operator\", value: \"=\" },\r\n                ],\r\n                hasBody: false,\r\n            },\r\n        ],\r\n    },\r\n};\r\n","// ---------------------------------------------------------------------------\n// Profile Resolver\n//\n// Handles profile inheritance via the `extends` field.\n// Merges parent and child profiles, with child overriding parent.\n// ---------------------------------------------------------------------------\n\nimport type { LanguageProfile } from \"../schema/profile.js\";\nimport type { LexerConfig, LexerState } from \"../schema/lexer.js\";\nimport type { StructureConfig } from \"../schema/structure.js\";\n\n/**\n * Resolve a profile's inheritance chain.\n * If the profile has `extends`, looks up the parent in the registry\n * and merges them (child overrides parent).\n */\nexport function resolveProfile(\n  profile: LanguageProfile,\n  registry: Map<string, LanguageProfile>,\n): LanguageProfile {\n  if (!profile.extends) return profile;\n\n  const parent = registry.get(profile.extends);\n  if (!parent) {\n    throw new Error(\n      `Profile \"${profile.name}\" extends \"${profile.extends}\" but parent not found in registry`,\n    );\n  }\n\n  // Resolve parent first (recursive)\n  const resolvedParent = resolveProfile(parent, registry);\n\n  return mergeProfiles(resolvedParent, profile);\n}\n\n/** Merge parent and child profiles. Child wins on conflicts. */\nfunction mergeProfiles(\n  parent: LanguageProfile,\n  child: LanguageProfile,\n): LanguageProfile {\n  return {\n    name: child.name,\n    displayName: child.displayName,\n    version: child.version,\n    fileExtensions: child.fileExtensions,\n    mimeTypes: child.mimeTypes ?? parent.mimeTypes,\n\n    // Merge lexer\n    lexer: mergeLexerConfig(parent.lexer, child.lexer),\n\n    // Merge structure (child wins entirely if present, otherwise inherit parent)\n    structure: child.structure ?? parent.structure\n      ? mergeStructureConfig(parent.structure, child.structure)\n      : undefined,\n\n    // Grammar: child wins entirely (no merge)\n    grammar: child.grammar ?? parent.grammar,\n\n    // Embedded languages: child wins entirely\n    embeddedLanguages: child.embeddedLanguages ?? parent.embeddedLanguages,\n  };\n}\n\nfunction mergeLexerConfig(\n  parent: LexerConfig,\n  child: LexerConfig,\n): LexerConfig {\n  // Merge char classes\n  const charClasses = {\n    ...(parent.charClasses ?? {}),\n    ...(child.charClasses ?? {}),\n  };\n\n  // Merge token types (child overrides)\n  const tokenTypes = {\n    ...parent.tokenTypes,\n    ...child.tokenTypes,\n  };\n\n  // Merge states: child states override parent states entirely\n  // But parent-only states are preserved\n  const states: Record<string, LexerState> = {};\n  for (const [name, state] of Object.entries(parent.states)) {\n    states[name] = state;\n  }\n  for (const [name, state] of Object.entries(child.states)) {\n    states[name] = state;\n  }\n\n  return {\n    charClasses,\n    tokenTypes,\n    states,\n    initialState: child.initialState ?? parent.initialState,\n    skipTokens: child.skipTokens ?? parent.skipTokens,\n    indentation: child.indentation ?? parent.indentation,\n  };\n}\n\nfunction mergeStructureConfig(\n  parent: StructureConfig | undefined,\n  child: StructureConfig | undefined,\n): StructureConfig | undefined {\n  if (!parent && !child) return undefined;\n  if (!parent) return child;\n  if (!child) return parent;\n\n  return {\n    // Child blocks override parent entirely\n    blocks: child.blocks.length > 0 ? child.blocks : parent.blocks,\n    // Child symbols added to parent symbols (child first for priority)\n    symbols: [...child.symbols, ...parent.symbols],\n    // Child folding overrides\n    folding: child.folding ?? parent.folding,\n  };\n}\n","import type { LanguageProfile } from \"../schema/profile.js\";\nimport { json } from \"./json.js\";\nimport { css } from \"./css.js\";\nimport { scss } from \"./scss.js\";\nimport { python } from \"./python.js\";\nimport { go } from \"./go.js\";\nimport { javascript } from \"./javascript.js\";\nimport { typescript } from \"./typescript.js\";\nimport { cpp } from \"./cpp.js\";\nimport { html } from \"./html.js\";\nimport { markdown } from \"./markdown.js\";\nimport { yaml } from \"./yaml.js\";\nimport { xml } from \"./xml.js\";\nimport { java } from \"./java.js\";\nimport { csharp } from \"./csharp.js\";\nimport { rust } from \"./rust.js\";\nimport { ruby } from \"./ruby.js\";\nimport { php } from \"./php.js\";\nimport { kotlin } from \"./kotlin.js\";\nimport { swift } from \"./swift.js\";\nimport { shell } from \"./shell.js\";\nimport { bash } from \"./bash.js\";\nimport { sql } from \"./sql.js\";\nimport { toml } from \"./toml.js\";\n\n// Re-export individual profiles\nexport {\n  json,\n  css,\n  scss,\n  python,\n  go,\n  javascript,\n  typescript,\n  cpp,\n  html,\n  markdown,\n  yaml,\n  xml,\n  java,\n  csharp,\n  rust,\n  ruby,\n  php,\n  kotlin,\n  swift,\n  shell,\n  bash,\n  sql,\n  toml,\n};\nexport { resolveProfile } from \"./resolver.js\";\n\n/** All built-in language profiles */\nexport const builtinProfiles: LanguageProfile[] = [\n  json,\n  css,\n  scss,\n  python,\n  go,\n  javascript,\n  typescript,\n  cpp,\n  html,\n  markdown,\n  yaml,\n  xml,\n  java,\n  csharp,\n  rust,\n  ruby,\n  php,\n  kotlin,\n  swift,\n  shell,\n  bash,\n  sql,\n  toml,\n];\n\n// ---------------------------------------------------------------------------\n// Profile registry\n// ---------------------------------------------------------------------------\n\n/** Map of profile name -> profile */\nconst profilesByName = new Map<string, LanguageProfile>();\n\n/** Map of file extension -> profile */\nconst profilesByExtension = new Map<string, LanguageProfile>();\n\n/** Register a language profile */\nexport function registerProfile(profile: LanguageProfile): void {\n  profilesByName.set(profile.name, profile);\n  for (const ext of profile.fileExtensions) {\n    profilesByExtension.set(ext.toLowerCase(), profile);\n  }\n}\n\n/** Get a profile by name (e.g., 'typescript') or file extension (e.g., '.ts') */\nexport function getProfile(nameOrExt: string): LanguageProfile | undefined {\n  return (\n    profilesByName.get(nameOrExt) ??\n    profilesByExtension.get(nameOrExt.toLowerCase())\n  );\n}\n\n/** Get all registered profile names */\nexport function getRegisteredLanguages(): string[] {\n  return Array.from(profilesByName.keys());\n}\n\n/** Get the file extensions supported by all registered profiles */\nexport function getSupportedExtensions(): string[] {\n  return Array.from(profilesByExtension.keys());\n}\n\n// Register all built-in profiles\nfor (const profile of builtinProfiles) {\n  registerProfile(profile);\n}\n"],"mappings":"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","names":[]}